<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java4210: Getting Started with Generics</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m47554</md:content-id>
  <md:title>Java4210: Getting Started with Generics</md:title>
  <md:abstract>This module presents and explains several simple programs that provide a first look into Java Generics.</md:abstract>
  <md:uuid>4acd2bdb-ed66-4d33-92e4-463bc9308dc3</md:uuid>
</metadata>

<content>






<para id="p1000">
Revised: Wed May 11 17:07:35 CDT 2016

</para>




<para id="p1001">
<emphasis id="em1000" effect="italics">
This page is included in the following Books:

</emphasis>
</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">

	

<link id="a1000" url="http://cnx.org/contents/Rl23r3Lw">


<emphasis id="em1001" effect="italics">
ITSE2317 - Java Programming (Intermediate)

</emphasis>
</link>


</item>


	

<item id="li1001">

	

<link id="a1001" url="http://cnx.org/contents/-2RmHFs_">


<emphasis id="em1002" effect="italics">
Object-Oriented Programming (OOP) with Java 
	

</emphasis>
 
	

</link>

 

</item>




</list>













<section id="h11000">
<title>
<emphasis id="Table_of_Contents" effect="bold">

Table of Contents

</emphasis>


</title>






<list id="ul1001" list-type="bulleted">
<item id="li1002">
<link id="a1002" target-id="Table_of_Contents">

Table of Contents

</link>




</item>


<item id="li1003">
<link id="a1003" target-id="Preface">

Preface

</link>




<list id="ul1002" list-type="bulleted">
<item id="li1004">
<link id="a1004" target-id="Viewing_tip">

Viewing tip

</link>




<list id="ul1003" list-type="bulleted">
<item id="li1005">
<link id="a1005" target-id="Figures">

Figures

</link>




</item>


<item id="li1006">
<link id="a1006" target-id="Listings">

Listings

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1007">
<link id="a1007" target-id="General_background_information">

General 
	background information

</link>




</item>


<item id="li1008">
<link id="a1008" target-id="Preview">

Preview

</link>




</item>


<item id="li1009">
<link id="a1009" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>




<list id="ul1004" list-type="bulleted">
<item id="li1010">
<link id="a1010" target-id="Collection_behavior_prior_to_Java_version_15">

Collection behavior prior to Java version 1.5

</link>




</item>


<item id="li1011">
<link id="a1011" target-id="An_incorrect_cast_in_code_that_doesnt_use_generics">

An incorrect cast in code that doesn't use generics

</link>




</item>


<item id="li1012">
<link id="a1012" target-id="Dealing_with_angle_brackets_in_cnxml_body_text">

Dealing with angle brackets in cnxml body text

</link>




</item>


<item id="li1013">
<link id="a1013" target-id="Avoiding_the_requirement_to_cast_through_the_use_of_generics">

Avoiding the requirement to cast through the use of generics

</link>




</item>


<item id="li1014">
<link id="a1014" target-id="CompileTime_type_safety_provided_by_the_use_of_generics">

Compile-time type safety provided by the use of generics

</link>




</item>


<item id="li1015">
<link id="a1015" target-id="Generic_iterator_syntax_and_the_enhanced_for_loop">

Generic iterator syntax and the enhanced for loop

</link>




</item>


</list>


</item>


<item id="li1016">
<link id="a1016" target-id="Run_the_program">

Run the programs

</link>




</item>


<item id="li1017">
<link id="a1017" target-id="Summary">

Summary

</link>




</item>


<item id="li1018">
<link id="a1018" target-id="Whats_next">

What's next?

</link>




</item>


<item id="li1019">
<link id="a1019" target-id="Miscellaneous">

Miscellaneous

</link>




</item>


<item id="li1020">
<link id="a1020" target-id="Complete_program_listing">

Complete program listings

</link>




</item>


</list>




	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
This module is one in a collection of modules on Java Generics designed for teaching 
	

<emphasis id="em1003" effect="italics">
ITSE2317 - Java Programming (Intermediate)

</emphasis>
 at Austin 
	Community College in Austin, TX.   

</para>





<para id="p1003">
<emphasis id="strong1000" effect="bold">
Many new features in Java version 1.5

</emphasis>
</para>





<para id="p1004">
When Java version 1.5 was released, it contained many new language 
features, including:

</para>





<list id="ul1005" list-type="bulleted">

	

<item id="li1021">
Generics

</item>


	

<item id="li1022">
Enhanced for Loop

</item>


	

<item id="li1023">
Autoboxing/Unboxing

</item>


	

<item id="li1024">
Typesafe Enums

</item>


	

<item id="li1025">
Varargs

</item>


	

<item id="li1026">
Static Import

</item>


	

<item id="li1027">
Metadata

</item>




</list>




<para id="p1005">
In addition to the new language features, Java version 1.5 also contained other new features such as new 


<emphasis id="em1004" effect="italics">
Look and Feel

</emphasis>
 capabilities for 
Swing GUIs.

</para>





<para id="p1006">
<emphasis id="strong1001" effect="bold">
First in a series

</emphasis>
</para>





<para id="p1007">
This is the first module in a series of modules designed to teach you about 
Generics in Java version 1.5. This 
module will teach you some of the rudimentary aspects of the generics capability

<emphasis id="em1005" effect="italics">
.

</emphasis>
 This module will also teach you 
how to use the 

<emphasis id="em1006" effect="italics">
enhanced

<emphasis id="strong1002" effect="bold">
 for

</emphasis>
 loop

</emphasis>
 with collections.

</para>





<para id="p1008">
Future modules will teach you how to use other aspects of generics

</para>




	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1009">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and the Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1006" list-type="bulleted">

		

<item id="li1028">
<link id="a1021" target-id="Figure_1">

Figure 1

</link>

. Typical v1.5 compiler warning.  

</item>


		

<item id="li1029">
<link id="a1022" target-id="Figure_2">

Figure 2

</link>

. Warning with -Xlint:unchecked.

</item>


		

<item id="li1030">
<link id="a1023" target-id="Figure_3">

Figure 3

</link>

. A ClassCastException.

</item>


		

<item id="li1031">
<link id="a1024" target-id="Figure_4">

Figure 4

</link>

. A compiler error. 

</item>


		

<item id="li1032">
<link id="a1025" target-id="Figure_5">

Figure 5

</link>

. Iterator output. 

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1007" list-type="bulleted">

		

<item id="li1033">
<link id="a1026" target-id="Listing_1">

Listing 1

</link>

. Beginning of the program named 
		Generics05.

</item>


		

<item id="li1034">
<link id="a1027" target-id="Listing_2">

Listing 2

</link>

. Beginning of the runIt method. 

</item>


		

<item id="li1035">
<link id="a1028" target-id="Listing_3">

Listing 3

</link>

. An iterator. 

</item>


		

<item id="li1036">
<link id="a1029" target-id="Listing_4">

Listing 4

</link>

. Enhanced for loop. 

</item>


		

<item id="li1037">
<link id="a1030" target-id="Listing_5">

Listing 5

</link>

. The program named Generics01.

</item>


		

<item id="li1038">
<link id="a1031" target-id="Listing_6">

Listing 6

</link>

. The program named Generics02.

</item>


		

<item id="li1039">
<link id="a1032" target-id="Listing_7">

Listing 7

</link>

. The program named Generics03.

</item>


		

<item id="li1040">
<link id="a1033" target-id="Listing_8">

Listing 8

</link>

. The program named Generics04.

</item>


		

<item id="li1041">
<link id="a1034" target-id="Listing_9">

Listing 9

</link>

. The program named Generics05.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<para id="p1010">
<emphasis id="strong1003" effect="bold">
A new compiler warning

</emphasis>
</para>





<para id="p1011">
Have you recently tried to recompile a legacy program that has compiled and 
executed properly for many years only to get a compiler message similar to that 
shown in 

<link id="a1035" target-id="Figure_1">

Figure 1

</link>

?

</para>




	

<table id="table1000" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">

				

<entry id="th1000">
<emphasis id="Figure_1" effect="bold">

Figure 1

</emphasis>

 - Typical v1.5 
				compiler warning.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">



<code id="pre1000" display="block">
Note: Generics01.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
</code>




							

</entry>

						

</row>

					

</tbody>


				

</tgroup>
</table>




<para id="p1012">
If you followed up and recompiled as directed, you probably got a message 
from the compiler that looked something like the one shown in 

<link id="a1036" target-id="Figure_2">

Figure 2

</link>

.

</para>




	

<table id="table1001" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">

				

<entry id="th1001">
<emphasis id="Figure_2" effect="bold">

Figure 2

</emphasis>

 - Warning with 
				-Xlint:unchecked.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">



<code id="pre1001" display="block">
Generics01.java:34: warning: [unchecked] unchecked call to add(E) as a member of
 the raw type ArrayList
    var1.add(new Date());
            ^
  where E is a type-variable:
    E extends Object declared in class ArrayList
1 warning
</code>



							

</entry>

						

</row>

					

</tbody>


				

</tgroup>
</table>




<para id="p1013">
If that has happened to you, you have had your first encounter with a new feature 
in Java version 1.5 known as 

<emphasis id="em1007" effect="italics">
generics.

</emphasis>
</para>





<para id="p1014">
<emphasis id="strong1004" effect="bold">
What are generics?

</emphasis>
</para>





<para id="p1015">
Oracle has this to say about generics 

<emphasis id="em1008" effect="italics">
(boldface added for emphasis):

</emphasis>
</para>





<note id="note1000" type="">



	

<para id="p1016">
<emphasis id="em1009" effect="italics">
"This long-awaited enhancement to the type system allows a type or 
	method to operate on objects of various types while providing 

<emphasis id="strong1005" effect="bold">

	compile-time type safety

</emphasis>
. It adds compile-time type safety to the 
	Collections Framework and eliminates the drudgery of casting."

</emphasis>
</para>





</note>






<para id="p1017">
In addition to the Collections Framework, generics impacts several other 
areas of Java programming as well.

</para>





<para id="p1018">
<emphasis id="strong1006" effect="bold">
Generics are not particularly easy

</emphasis>
</para>





<para id="p1019">
Don't be lulled into a false sense of security by what you will find in this 
module. Although the introductory material presented in this module is 
rather straightforward, a full understanding of generics can be fairly 
difficult. The tentacles of generics reach into many different areas of 
Java in very complex ways.

</para>





<para id="p1020">
The truth of this is borne out by the fact that the excellent book entitled


<link id="a1037" url="http://www.amazon.com/exec/obidos/ASIN/0131483986/qid=1110389658/sr=11-1/ref=sr_11_1/102-4105266-9447324">


Java How to Program, Sixth Edition (Deitel)

</link>

 dedicates an entire chapter 
consisting of more than 30 pages to generics. Furthermore, the chapter on 
generics doesn't even include many additional pages that the book dedicates to a 
discussion of the impact of generics on the Java Collections Framework. 
The book covers several topics in the chapter on generics, including the 
following:

</para>





<list id="ul1008" list-type="bulleted">

	

<item id="li1042">
Generic methods

</item>


	

<item id="li1043">
Generic classes

</item>


	

<item id="li1044">
Raw types

</item>


	

<item id="li1045">
Wildcards

</item>


	

<item id="li1046">
Generics and inheritance

</item>




</list>




<para id="p1021">
The impact of generics on the Java Collections Framework is covered in a 
different chapter. Hopefully, the benefits provided by generics will outweigh 
the additional complexity. Only time will tell.

</para>





<para id="p1022">
<emphasis id="strong1007" effect="bold">
The Java Collections Framework

</emphasis>
</para>





<para id="p1023">
Even though the material that will be presented in this module will be 
relatively straightforward, you will need to know something about the Java 
Collections Framework for it to make much sense. If you need to learn more 
about the Java Collections Framework, see the modules beginning with 


<link id="a1038" url="http://cnx.org/contents/dzOvxPFw:BaPSYll8">

Java4010: Getting Started with Java Collections

</link>

 
at I

<link id="a1039" url="http://cnx.org/contents/dzOvxPFw">

TSE 2321 - Object-Oriented 
Programming (Java)

</link>

. Be aware, however, that those 
modules were originally published long before generics existed in Java. If you 
compile the programs in those modules using Java version 1.5 or a later version, you will get the 
warning messages from the compiler shown in 

<link id="a1040" target-id="Figure_1">

Figure 1

</link>

.

</para>



	

</section>
<section id="h11003">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>


	


<para id="p1024">
I will present and explain several very simple programs in this module. Those 
programs are intended to illustrate the following concepts:

</para>





<list id="ul1009" list-type="bulleted">

	

<item id="li1047">
How the Java Collections Framework behaved prior to the release of Java 
	version 1.5.

</item>


	

<item id="li1048">
The effect of an incorrect cast in code that doesn't use generics.

</item>


	

<item id="li1049">
Avoiding the requirement to cast through the use of generics. This 
	program also includes an illustration of some of the required syntax for 
	generics.

</item>


	

<item id="li1050">
Compile-time type safety provided by the use of generics.

</item>


	

<item id="li1051">
Syntax requirements for the use of iterators with generics. This 
	program also illustrates the use of the enhanced 

<emphasis id="strong1008" effect="bold">
for

</emphasis>
 loop with 
	collections, which is another new feature in Java version 1.5.

</item>




</list>


	

</section>
<section id="h11004">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	


<para id="p1025">
<emphasis id="strong1009" effect="bold">
Listings of the programs

</emphasis>
</para>





<para id="p1026">
Complete listings of all the programs discussed in this module are provided 
in 

<link id="a1041" target-id="Listing_5">

Listing 5

</link>

 through 

<link id="a1042" target-id="Listing_9">

Listing 9

</link>

  near the end of the module.

</para>





<section id="h21001">
<title>
<emphasis id="Collection_behavior_prior_to_Java_version_15" effect="bold">

Collection behavior prior to Java version 1.5

</emphasis>


</title>




<para id="p1027">
The main purpose of the program named 

<emphasis id="strong1010" effect="bold">
Generics01

</emphasis>
 is to establish a 
baseline against which to compare the other programs. A secondary purpose 
is to illustrate the warnings produced by the Java version 1.5 

<emphasis id="em1010" effect="italics">
(or later)

</emphasis>
 compiler when the 
syntax of the source code doesn't take generics into account.

</para>





<para id="p1028">
A complete listing of the program named 

<emphasis id="strong1011" effect="bold">
Generics01

</emphasis>
 is shown in 


<link id="a1043" target-id="Listing_5">

Listing 5

</link>

 near the end of the module.

</para>





<para id="p1029">
As you will see later, this program was written using the program syntax and 
style that was common prior to the release of Java version 1.5. In 
particular, this program does not include the syntax necessary to take generics 
into account.

</para>





<para id="p1030">
<emphasis id="strong1012" effect="bold">
Notes at compile time

</emphasis>
</para>






<para id="p1031">
When this program is compiled using the Java version 1.5 or later compiler, the text 
shown in 

<link id="a1044" target-id="Figure_1">

Figure 1

</link>

 appears on the screen.

</para>



	

<para id="p1032">
Note that the text in 

<link id="a1045" target-id="Figure_1">

Figure 1

</link>

 is not identified as either an error or a 
	warning. Rather, the text is identified simply as notes. These 
	notes provide instructions on how to recompile and get more information 
	regarding a potential problem.

</para>





<para id="p1033">
<emphasis id="strong1013" effect="bold">
Recompiling with the Xlint switch

</emphasis>
</para>





<para id="p1034">
When the program is recompiled using the Xlint switch shown in 

<link id="a1046" target-id="Figure_1">

Figure 1

</link>

, the 
compiler produces the text shown in 

<link id="a1047" target-id="Figure_2">

Figure 2

</link>

. Note that this text is 
identified as a warning.

</para>





<note id="note1001" type="">



	

<para id="p1035">
<emphasis id="em1011" effect="italics">
(Later when we examine the code from the program named 

<emphasis id="strong1014" effect="bold">
Generics01

</emphasis>
, 
	you can compare it with this text to see just what the compiler is 
	complaining about.)

</emphasis>
</para>





</note>




	

<para id="p1036">
<emphasis id="strong1015" effect="bold">
Get used to it

</emphasis>
</para>





<para id="p1037">
The text in 

<link id="a1048" target-id="Figure_1">

Figure 1

</link>

 and 

<link id="a1049" target-id="Figure_2">

Figure 2

</link>

 is similar to what you can expect to see 
any time that you use the Java version 1.5 or later compiler to compile a program that 
includes the Java Collections Framework and doesn't use the required syntax to 
take generics into account. This probably includes many of the programs 
that you wrote, compiled, and executed successfully prior to the release of Java 
version 1.5.

</para>





<para id="p1038">
<emphasis id="strong1016" effect="bold">
The program code

</emphasis>
</para>





<para id="p1039">
The code for the program named 

<emphasis id="strong1017" effect="bold">
Generics01

</emphasis>
 is shown in its entirety in 


<link id="a1050" target-id="Listing_5">

Listing 5

</link>

.

</para>






<para id="p1040">
<emphasis id="strong1018" effect="bold">
The main method

</emphasis>
</para>





<para id="p1041">
As you can see in 

<link id="a1051" target-id="Listing_5">

Listing 5

</link>

, the 

<emphasis id="strong1019" effect="bold">
main

</emphasis>
 method instantiates a new object 
of the class named 

<emphasis id="strong1020" effect="bold">
Generics01

</emphasis>
, and calls the method named 

<emphasis id="strong1021" effect="bold">
runIt

</emphasis>
 
on that object. It is the behavior of the 

<emphasis id="strong1022" effect="bold">
runIt

</emphasis>
 method that 
interests us. More particularly, it is the expression contained in the 
argument list for the 

<emphasis id="strong1023" effect="bold">
println 

</emphasis>
method

<emphasis id="strong1024" effect="bold">
 

</emphasis>
that interests us the most.

</para>





<para id="p1042">
<emphasis id="strong1025" effect="bold">
A baseline program

</emphasis>
</para>





<para id="p1043">
As mentioned earlier, the main purpose of this program is to establish a 
baseline against which we can compare the other programs to be discussed later. 
This program was written exactly as it would have been written prior to the 
release of generics in Java version 1.5.

</para>





<para id="p1044">
<emphasis id="strong1026" effect="bold">
An ArrayList object

</emphasis>
</para>





<para id="p1045">
The program declares and initializes an instance variable named 

<emphasis id="strong1027" effect="bold">
var1

</emphasis>
 
with a reference to an object instantiated from the class named 

<emphasis id="strong1028" effect="bold">
ArrayList

</emphasis>
.


<emphasis id="strong1029" effect="bold">
ArrayList

</emphasis>
 is one of the concrete implementations of the interfaces 
provided in the Java Collections Framework. Briefly, an object of the 

<emphasis id="strong1030" effect="bold">

ArrayList

</emphasis>
 class is an object that implements the 

<emphasis id="strong1031" effect="bold">

List

</emphasis>
 interface, providing a convenient place to store references to other 
objects.

</para>





<para id="p1046">
One of the methods of an 

<emphasis id="strong1032" effect="bold">
ArrayList

</emphasis>
 object is the method named 

<emphasis id="strong1033" effect="bold">
add

</emphasis>
. 
This method is used to add new elements to the end of the list.

</para>





<para id="p1047">
<emphasis id="strong1034" effect="bold">
Adding a Date object's reference to the list

</emphasis>
</para>





<para id="p1048">
<link id="a1052" target-id="Listing_5">

Listing 5

</link>

 calls the 

<emphasis id="strong1035" effect="bold">
add

</emphasis>
 method to add a new 

<emphasis id="strong1036" effect="bold">
Date

</emphasis>
 object's 
reference to the list.

</para>





<note id="note1002" type="">



	

<para id="p1049">
<emphasis id="em1012" effect="italics">
(This is the method call that the compiler was complaining about 
	in the warning in 

<link id="a1053" target-id="Figure_2">

Figure 2

</link>

.)

</emphasis>
</para>





</note>






<para id="p1050">
When an object's reference is added to an 

<emphasis id="strong1037" effect="bold">
ArrayList

</emphasis>
 object 

<emphasis id="em1013" effect="italics">
(without 
the use of generic syntax),

</emphasis>
 that reference is automatically converted to and 
stored as type 

<emphasis id="strong1038" effect="bold">
Object

</emphasis>
.

</para>





<note id="note1003" type="">



	

<para id="p1051">
<emphasis id="em1014" effect="italics">
(As you will see later, that is probably also true even with the use of generic syntax. 
	I will have more to say about this later.)

</emphasis>
</para>





</note>






<para id="p1052">
<emphasis id="strong1039" effect="bold">
What can you do with a reference of type Object?

</emphasis>
</para>





<para id="p1053">
I often tell my students that there are only twelve things that you can do 
with an object's reference that has been converted to type 

<emphasis id="strong1040" effect="bold">
Object

</emphasis>
. 
The first eleven of those twelve things is to call any one of the eleven 
methods that are defined in the 

<emphasis id="strong1041" effect="bold">
Object

</emphasis>
 class and inherited into all 
subclasses of 

<emphasis id="strong1042" effect="bold">
Object

</emphasis>
. The twelfth thing is to attempt to cast the 
reference to some other type in an attempt to call some other method on the 
reference after casting.

</para>





<para id="p1054">
<emphasis id="strong1043" effect="bold">
Invoking getTime on the reference

</emphasis>
</para>





<para id="p1055">
The objective of the code in this program is to call the method named 

<emphasis id="strong1044" effect="bold">

getTime

</emphasis>
 on the 

<emphasis id="strong1045" effect="bold">
Date

</emphasis>
 object's reference. The 

<emphasis id="strong1046" effect="bold">
getTime

</emphasis>
 
method is not one of the eleven methods that are defined in the 

<emphasis id="strong1047" effect="bold">
Object

</emphasis>
 
class. Rather, the 

<emphasis id="strong1048" effect="bold">
getTime

</emphasis>
 method is defined in the 

<emphasis id="strong1049" effect="bold">
Date

</emphasis>
 class.

</para>





<para id="p1056">
<emphasis id="strong1050" effect="bold">
Change the type of the reference

</emphasis>
</para>





<para id="p1057">
Therefore, in order to call the 

<emphasis id="strong1051" effect="bold">
getTime

</emphasis>
 method on the reference 
after it is retrieved from the 

<emphasis id="strong1052" effect="bold">
ArrayList

</emphasis>
 object, the type of the 
reference must be converted from type 

<emphasis id="strong1053" effect="bold">
Object

</emphasis>
 to type 

<emphasis id="strong1054" effect="bold">
Date

</emphasis>
. 
This is accomplished by the cast operation in the expression contained 
in the argument list for the 

<emphasis id="strong1055" effect="bold">
println 

</emphasis>
method

<emphasis id="strong1056" effect="bold">
 

</emphasis>

in 

<link id="a1054" target-id="Listing_5">

Listing 5

</link>

.

</para>





<para id="p1058">
That expression calls the 

<emphasis id="strong1057" effect="bold">
get

</emphasis>
 method on the reference 
to the 

<emphasis id="strong1058" effect="bold">
ArrayList

</emphasis>
 object to retrieve the element stored at index 0 of the 
collection. The 

<emphasis id="strong1059" effect="bold">
get

</emphasis>
 method returns the reference as type 

<emphasis id="strong1060" effect="bold">
Object

</emphasis>



<emphasis id="em1015" effect="italics">
(at least that was true prior to the introduction of generics).

</emphasis>
 
Then the expression casts the reference to type 

<emphasis id="strong1061" effect="bold">
Date

</emphasis>
, 
converting its type back to type 

<emphasis id="strong1062" effect="bold">
Date

</emphasis>
. 

</para>





<para id="p1059">
<emphasis id="strong1063" effect="bold">
Invoking the getTime method

</emphasis>
</para>





<para id="p1060">
Finally, the expression successfully calls the 

<emphasis id="strong1064" effect="bold">
getTime

</emphasis>
 
method on the reference of type 

<emphasis id="strong1065" effect="bold">
Date

</emphasis>
.

</para>





<para id="p1061">
The program produces an output similar to that shown below:

</para>





<para id="p1062">
<emphasis id="strong1066" effect="bold">
1377991758665

</emphasis>
</para>





<para id="p1063">
This is the number of milliseconds since January 1, 1970, 00:00:00 GMT 
represented by the 

<emphasis id="strong1067" effect="bold">
Date

</emphasis>
 object.

</para>





<para id="p1064">
<emphasis id="strong1068" effect="bold">
Casting was a necessity prior to Java version 1.5

</emphasis>
</para>





<para id="p1065">
Prior to the release of Java version 1.5, it was always necessary to cast 
references retrieved from collection objects in order to call any methods on 
them other than the eleven methods defined in the 

<emphasis id="strong1069" effect="bold">
Object

</emphasis>
 class.

</para>





<para id="p1066">
Some authors refer to this casting requirement as 

<emphasis id="em1016" effect="italics">
"the drudgery of 
casting,"

</emphasis>
 and indicate that casting may be eliminated through generics.

</para>





<note id="note1004" type="">



	

<para id="p1067">
<emphasis id="em1017" effect="italics">
(In my opinion, from this viewpoint alone, the cure is worse than the 
	disease. Casting syntax is much simpler and more straightforward than 
	generics syntax.)

</emphasis>
</para>





</note>






<para id="p1068">
<emphasis id="strong1070" effect="bold">
May eliminate runtime errors and exceptions

</emphasis>
</para>





<para id="p1069">
However, it is possible for the programmer to perform an incorrect cast at 
this point in the program, which will usually result in a 

<emphasis id="strong1071" effect="bold">
ClassCastException

</emphasis>
 
being thrown at runtime.

</para>





<para id="p1070">
The great promise of generics is that it can sometimes cause programming 
errors to be recognized at compile time instead of encountering them at runtime.

</para>





<para id="p1071">
Obviously, the best approach is to avoid writing programs containing 
programming errors in the first place. However, if you are going to write 
programs containing errors, it is usually better to catch them at compile time 
than to have them occur at runtime. This is the thing that may make the 
complexity of generics worthwhile.

</para>









</section>
<section id="h21002">
<title>
<emphasis id="An_incorrect_cast_in_code_that_doesnt_use_generics" effect="bold">

An incorrect cast in code that doesn't use generics

</emphasis>


</title>




<para id="p1072">
The program named 

<emphasis id="strong1072" effect="bold">
Generics02

</emphasis>
 

<emphasis id="em1018" effect="italics">
(shown later in 

<link id="a1055" target-id="Listing_6">

Listing 6

</link>

)

</emphasis>
 
illustrates the application of an incorrect cast to an element that is retrieved 
from an 

<emphasis id="strong1073" effect="bold">
ArrayList

</emphasis>
 object, along with the runtime error that is produced 
by that incorrect cast.

</para>





<para id="p1073">
<emphasis id="strong1074" effect="bold">
No compiler error

</emphasis>
</para>





<para id="p1074">
This program does not produce a compiler error.

</para>





<note id="note1005" type="">



	

<para id="p1075">
<emphasis id="em1019" effect="italics">
(However, the Java version 1.5 compiler does produce a warning having 
	to do with the failure to apply the new generics syntax that was released in 
	Java version 1.5. Note that earlier compilers would not have produced 
	such a warning.)

</emphasis>
</para>





</note>






<para id="p1076">
The point here is that the compiler does not check to confirm that the 
correct cast is applied. This results in a successful compilation, but the 
program throws an exception at runtime.

</para>





<para id="p1077">
<emphasis id="strong1075" effect="bold">
A ClassCastException

</emphasis>
</para>





<para id="p1078">
The runtime exception that is thrown by this program is shown in 

<link id="a1056" target-id="Figure_3">

Figure 3

</link>

. 
You can compare the details of this exception with the program code later. 
The reference to line 46 in 

<link id="a1057" target-id="Figure_3">

Figure 3

</link>

 is a reference to the statement in 


<link id="a1058" target-id="Listing_6">

Listing 6

</link>

 that attempts to cast the reference to type 

<emphasis id="strong1076" effect="bold">
Date 

</emphasis>
.


<emphasis id="em1020" effect="italics">
(That reference was originally a reference to an object of type 

<emphasis id="strong1077" effect="bold">

String

</emphasis>
.)

</emphasis>
</para>





	

<table id="table1002" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">

				

<entry id="th1002">
<emphasis id="Figure_3" effect="bold">

Figure 3

</emphasis>

 - A 
				ClassCastException.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">



<code id="pre1002" display="block">
Exception in thread "main" java.lang.ClassCastException: 
 java.lang.String cannot
 be cast to java.util.Date
        at Generics02.runIt(Generics02.java:46)
        at Generics02.main(Generics02.java:53)
</code>



							

</entry>

						

</row>

					

</tbody>


				

</tgroup>
</table>


	

<para id="p1079">
<emphasis id="strong1078" effect="bold">
The program code

</emphasis>
</para>





<para id="p1080">
The program is shown in its entirety in 

<link id="a1059" target-id="Listing_6">

Listing 6

</link>

. As before, the 

<emphasis id="strong1079" effect="bold">
main

</emphasis>
 
method instantiates an object of the 

<emphasis id="strong1080" effect="bold">
Generics02

</emphasis>
 class and calls the 

<emphasis id="strong1081" effect="bold">

runIt

</emphasis>
 
method on that object. Also as in the previous program, this program 
instantiates a new 

<emphasis id="strong1082" effect="bold">
ArrayList

</emphasis>
 object and saves the object's reference in 
the instance variable named 

<emphasis id="strong1083" effect="bold">
var1

</emphasis>
.

</para>






<para id="p1081">
<emphasis id="strong1084" effect="bold">
The runIt method

</emphasis>
</para>





<para id="p1082">
The 

<emphasis id="strong1085" effect="bold">
runIt

</emphasis>
 method begins by populating the 

<emphasis id="strong1086" effect="bold">
ArrayList

</emphasis>
 object with 
references to two different objects of different types. One of the objects 
is type 

<emphasis id="strong1087" effect="bold">
Date

</emphasis>
. The other object is type 

<emphasis id="strong1088" effect="bold">
String

</emphasis>
.

</para>





<para id="p1083">
<emphasis id="strong1089" effect="bold">
A questionable programming style

</emphasis>
</para>





<para id="p1084">
While this is probably not a very good programming style, it is a style that 
was commonly used by Java programmers prior to the advent of generics. It 
was common to populate collection objects with references to a mixture of 
objects of different types.

</para>





<para id="p1085">
<emphasis id="strong1090" effect="bold">
References are stored as type Object

</emphasis>
</para>





<para id="p1086">
As you already know, when these object's references are put into the 
collection, the types of all the references are automatically converted to type


<emphasis id="strong1091" effect="bold">
Object

</emphasis>
. As you also already know, when the references are retrieved 
from the collection, if the purpose is to call any method on a reference other 
than one of the eleven methods defined in the 

<emphasis id="strong1092" effect="bold">
Object

</emphasis>
 class, it is 
necessary to cast the reference to a type that is consistent with the method.

</para>





<para id="p1087">
<emphasis id="strong1093" effect="bold">
Casting errors are likely

</emphasis>
</para>





<para id="p1088">
This is a scenario where the programmer is likely to make a casting error 
when casting elements retrieved from the collection. Unless the programmer 
uses the 

<emphasis id="strong1094" effect="bold">
instanceof

</emphasis>
 operator to determine the type of a retrieved 
reference prior to performing the cast, the programmer is depending on his 
memory to know the type of each reference in the population on the basis of the 
index of the element. If the programmer loses track of the types of the 
different references with respect to the element's indices, a casting error is a 
strong possibility.

</para>





<para id="p1089">
<emphasis id="strong1095" effect="bold">
The error scenario

</emphasis>
</para>





<para id="p1090">
This is the error scenario depicted by the first call to the 

<emphasis id="strong1096" effect="bold">
println

</emphasis>
 
method in 

<link id="a1060" target-id="Listing_6">

Listing 6

</link>

. 
In this case, the element at index 0 is a reference to a 

<emphasis id="strong1097" effect="bold">
Date

</emphasis>
 object, and 
the element at index 1 is a reference to a 

<emphasis id="strong1098" effect="bold">
String

</emphasis>
 object. However, 
the programmer mistakenly retrieves the element at index 1 and attempts to cast 
it to type 

<emphasis id="strong1099" effect="bold">
Date

</emphasis>
, which is the type of the reference at index 0. 
This results in the runtime exception shown in 

<link id="a1061" target-id="Figure_3">

Figure 3

</link>

.

</para>





<para id="p1091">
Of course, it has always been possible to use the 

<emphasis id="strong1100" effect="bold">
instanceof

</emphasis>
 operator 
to confirm the type of a reference before performing a cast as a way to avoid 
this type of programming error. Good programming practice would dictate 
the use of that construct when working with references to objects of mixed types 
in a single collection.

</para>





</section>
<section id="h21003">
<title>
<emphasis id="Dealing_with_angle_brackets_in_cnxml_body_text" effect="bold">

Dealing with angle brackets in cnxml body text

</emphasis>


</title>




<para id="p1092">
You are reading this module at cnx.org. Documents published at cnx.org are 
maintained in a special flavor of xml know as cnxml. Without getting into the 
details, I will tell you that creating cnxml is not an easy task. In order to 
avoid having to write these modules in raw cnxml code, I originally write them 
using a WYSIWYG xhtml editor and then run the xhtml files through a program of my own 
design that transforms the xhtml document into cnxml.

</para>





<para id="p1093">
Unfortunately, my transform program is incapable of handling angle brackets 
in the body text of the document. Therefore, whenever the 
body text in this document needs a left angle bracket, I will indicate the 
existence of a left or right angle bracket using a text description of the angle 
bracket. The code in the 
listings, 
however, will show the left and right angle brackets intact as required.

</para>





</section>
<section id="h21004">
<title>
<emphasis id="Avoiding_the_requirement_to_cast_through_the_use_of_generics" effect="bold">

Avoiding the requirement to cast through the use of generics

</emphasis>


</title>




<para id="p1094">
The program named 

<emphasis id="strong1101" effect="bold">
Generics03

</emphasis>
 shown in 

<link id="a1062" target-id="Listing_7">

Listing 7

</link>

 illustrates how generics can be used 
to avoid the requirement to cast references when they are retrieved from a 
collection.

</para>





<note id="note1006" type="">



	

<para id="p1095">
<emphasis id="em1021" effect="italics">
(While casting is not difficult, avoiding the requirement to cast can 
	also avoid the possibility of casting incorrectly.)

</emphasis>
</para>





</note>






<para id="p1096">
As in the previous programs, the 

<emphasis id="strong1102" effect="bold">
main

</emphasis>
 method in this program 
instantiates an object of the class named 

<emphasis id="strong1103" effect="bold">
Generics03

</emphasis>
 and calls the 
method named 

<emphasis id="strong1104" effect="bold">
runIt

</emphasis>
 on the object.

</para>






<para id="p1097">
<emphasis id="strong1105" effect="bold">
Instantiate an ArrayList object

</emphasis>
</para>





<para id="p1098">
Also, as in the previous programs, this program declares an instance variable 
named 

<emphasis id="strong1106" effect="bold">
var1

</emphasis>
 and initializes that variable with a reference to a new object 
of type 

<emphasis id="strong1107" effect="bold">
ArrayList

</emphasis>
. However, the syntax that is used for this 
purpose in this program is significantly different from the syntax used for the 
same purpose in the previous two programs.

</para>





<note id="note1007" type="">



	

<para id="p1099">
<emphasis id="em1022" effect="italics">
(Note the code in 

<link id="a1063" target-id="Listing_7">

Listing 7

</link>

 that shows the type 

<emphasis id="strong1108" effect="bold">
Date

</emphasis>
 
	enclosed in matching angle brackets. This is the primary 
	syntax change required to use generics.)

</emphasis>
</para>





</note>






<para id="p1100">
<emphasis id="strong1109" effect="bold">
What does this syntax mean?

</emphasis>
</para>





<para id="p1101">
One way to think of this syntax is that the expression on the right of the 
assignment operator instantiates a new 

<emphasis id="strong1110" effect="bold">
ArrayList

</emphasis>
 
object that is capable of containing only references to objects of type 

<emphasis id="strong1111" effect="bold">
Date

</emphasis>
.

</para>





<note id="note1008" type="">



	

<para id="p1102">
<emphasis id="em1023" effect="italics">
(Those references are probably still stored as type 

<emphasis id="strong1112" effect="bold">
Object

</emphasis>
. We 
	will see how this apparent discrepancy is reconciled later through automatic 
	casting.)

</emphasis>
</para>





</note>






<para id="p1103">
Similarly, the expression on the left of the assignment operator is the 
declaration of an instance variable capable of holding a reference to an 

<emphasis id="strong1113" effect="bold">

ArrayList

</emphasis>
 
object, which in turn is capable of containing only references to objects of 
type 

<emphasis id="strong1114" effect="bold">
Date

</emphasis>
.

</para>





<para id="p1104">
<emphasis id="strong1115" effect="bold">
Must qualify both expressions

</emphasis>
</para>





<para id="p1105">
Additional changes to generics were made in the release of Java version 1.7. 
Prior to the release of Java version 1.7, it was necessary to qualify the expressions on both sides of the assignment 
operator by use of the angle-bracket syntax. If the qualifier was included 
in the expression on the right, but was omitted from the variable declaration on 
the left, the compilation would fail later. That is still true following 
the release of Java version 1.7.

</para>





<para id="p1106">
If the angle-bracket qualifier was included with the variable declaration on 
the left and omitted from the instantiation of the new object on the right, the 
program would compile and run successfully. However, the compiler 
would issue an 

<emphasis id="em1024" effect="italics">

unchecked conversion

</emphasis>
 warning indicating the possibility of a runtime error 
under certain conditions.

</para>





<para id="p1107">
Following the release of Java version 1.7, it is not necessary to qualify the 
expression on the right side of the assignment operator. You will learn more 
about this in a future module.

</para>





<para id="p1108">
<emphasis id="strong1116" effect="bold">
What does Oracle have to say?

</emphasis>
 

</para>





<para id="p1109">
According to Oracle 

<emphasis id="em1025" effect="italics">
(boldface added for emphasis),

</emphasis>
 

</para>





<note id="note1009" type="">



	

<para id="p1110">
<emphasis id="em1026" effect="italics">
"Generics provides a way for you to communicate the type of a 
	collection to the compiler, so that it can be checked. Once the compiler 
	knows the element type of the collection, the compiler can check that you 
	have used the collection consistently and 

<emphasis id="strong1117" effect="bold">
can insert the correct casts

</emphasis>
 
	on values being taken out of the collection."

</emphasis>
</para>





</note>






<para id="p1111">
Note the boldface text in the above quotation indicating that the compiler 
modifies your code by inserting casts where appropriate.

</para>





<para id="p1112">
<emphasis id="strong1118" effect="bold">
Compile-time type safety

</emphasis>
</para>





<para id="p1113">
In discussing code similar to the code in 

<link id="a1064" target-id="Listing_7">

Listing 7

</link>

, 
Oracle states,

</para>





<note id="note1010" type="">



	

<para id="p1114">
<emphasis id="em1027" effect="italics">
"... so the compiler can verify at compile time that the type 
	constraints are not violated at run time. Because the program compiles 
	without warnings, we can state with certainty that it will not throw a 

<emphasis id="strong1119" effect="bold">

	ClassCastException

</emphasis>
 at run time. The net effect of using generics, 
	especially in large programs, is improved readability and robustness."

</emphasis>
</para>





</note>






<para id="p1115">
In order to achieve compile-time type safety, it is necessary that the 
program compiles without warnings. Otherwise, the program may execute, but 
may throw a 

<emphasis id="strong1120" effect="bold">
ClassCastException

</emphasis>
 at runtime.

</para>





<para id="p1116">
<emphasis id="strong1121" effect="bold">
More on generics with collections

</emphasis>
</para>





<para id="p1117">
In further explaining generics as used with collections, Oracle goes on to say


<emphasis id="em1028" effect="italics">
(boldface added for emphasis):

</emphasis>
</para>





<note id="note1011" type="">



	

<para id="p1118">
<emphasis id="em1029" effect="italics">
"... when we declare c to be of type Collection (String in angle 
	brackets), this 
	tells us something about the variable c that holds true wherever and 
	whenever it is used, and the compiler guarantees it (assuming the program 
	

<emphasis id="strong1122" effect="bold">
compiles without warnings

</emphasis>
). A cast, on the other hand, tells us 
	something the programmer thinks is true at a single point in the code, and 
	the VM checks whether the programmer is right only at run time."

</emphasis>
</para>





</note>






<para id="p1119">
<emphasis id="strong1123" effect="bold">
The bottom line

</emphasis>
</para>





<para id="p1120">
The bottom line on generics 

<emphasis id="em1030" effect="italics">
(when used with collections)

</emphasis>
 seems to be 
that references to objects are still stored in the collection as type 

<emphasis id="strong1124" effect="bold">
Object

</emphasis>
. 
However, when we notify the compiler of the type of data to be stored in the 
collection using angle-bracket syntax, and the program compiles without 
warnings, the compiler will do at least the following:

</para>





<list id="ul1010" list-type="bulleted">

	

<item id="li1052">
Ensure that only references to objects of the specified type are stored 
	in the collection, and used consistently throughout the program, thus 
	eliminating the possibility of a 

<emphasis id="strong1125" effect="bold">
ClassCastException

</emphasis>
 at runtime.

</item>


	

<item id="li1053">
Automatically cast the reference to the specified type when it is later 
	retrieved by program code.

</item>




</list>




<para id="p1121">
<emphasis id="strong1126" effect="bold">
No explicit cast is required

</emphasis>
</para>





<para id="p1122">
That brings us back to a discussion of the code in 

<link id="a1065" target-id="Listing_7">

Listing 7

</link>

. Note that 
unlike the code in 

<link id="a1066" target-id="Listing_5">

Listing 5

</link>

, the print statement in 

<link id="a1067" target-id="Listing_7">

Listing 7

</link>

 does not contain 
an explicit cast to type 

<emphasis id="strong1127" effect="bold">
Date

</emphasis>
, 

<emphasis id="em1031" effect="italics">
(at least not in the code that I 
wrote).

</emphasis>
</para>





<para id="p1123">
As described above, having been notified that the collection can contain only 
references to objects of type 

<emphasis id="strong1128" effect="bold">
Date

</emphasis>
, the compiler automatically inserted a 
cast to type 

<emphasis id="strong1129" effect="bold">
Date

</emphasis>
 at the appropriate place in the code, thereby 
guaranteeing that the reference is converted from type 

<emphasis id="strong1130" effect="bold">
Object

</emphasis>
 to type 

<emphasis id="strong1131" effect="bold">

Date

</emphasis>
 before the 

<emphasis id="strong1132" effect="bold">
getTime

</emphasis>
 method is called on the reference. 

</para>





<para id="p1124">
There is still a cast involved. However, the cast is automatically 
inserted by the compiler. This eliminates the requirement for me 

<emphasis id="em1032" effect="italics">
(the 
programmer

</emphasis>
) to insert the cast, and also eliminates the possibility of me 
inserting an incorrect cast.

</para>





<para id="p1125">
Once again, all of this assumes that the program compiles without warnings.

</para>





<para id="p1126">
<emphasis id="strong1133" effect="bold">
Program output

</emphasis>
</para>





<para id="p1127">
The program in 

<link id="a1068" target-id="Listing_7">

Listing 7

</link>

 compiles and executes correctly, producing the 
following output for one particular run.


</para>



	

<para id="p1128">
<emphasis id="strong1134" effect="bold">
1377995720768

</emphasis>
</para>









</section>
<section id="h21005">
<title>
<emphasis id="CompileTime_type_safety_provided_by_the_use_of_generics" effect="bold">

Compile-time type safety provided by the use of generics

</emphasis>


</title>




<para id="p1129">
The program named 

<emphasis id="strong1135" effect="bold">
Generics04

</emphasis>
 shown in 

<link id="a1069" target-id="Listing_8">

Listing 8

</link>

 illustrates the ability of generics to prevent the storing of 
the wrong type of references in a collection. This in turn can prevent 
runtime errors.

</para>






<para id="p1130">
<emphasis id="strong1136" effect="bold">
A new ArrayList object

</emphasis>
</para>





<para id="p1131">
<link id="a1070" target-id="Listing_8">

Listing 8

</link>

 instantiates a new object of type 

<emphasis id="strong1137" effect="bold">

ArrayList

</emphasis>
 capable of storing only references to objects of type 

<emphasis id="strong1138" effect="bold">
Date

</emphasis>
. 
This object's reference is stored in the instance variable named 

<emphasis id="strong1139" effect="bold">
var1

</emphasis>
.

</para>





<para id="p1132">
<emphasis id="strong1140" effect="bold">
Other types cannot be stored in the collection

</emphasis>
</para>





<para id="p1133">
Once the 

<emphasis id="strong1141" effect="bold">
ArrayList

</emphasis>
 has been constrained to contain only references to 
objects of type 

<emphasis id="strong1142" effect="bold">
Date

</emphasis>
, the compiler will not allow a reference to an 
object of any other type 

<emphasis id="em1033" effect="italics">
(other than types that are assignment compatible 
with 

<emphasis id="strong1143" effect="bold">
Date

</emphasis>
, such as subclasses of 

<emphasis id="strong1144" effect="bold">
Date

</emphasis>
)

</emphasis>
 to be stored in the 
collection.

</para>





<para id="p1134">
<emphasis id="strong1145" effect="bold">
A compiler error rather than a runtime error

</emphasis>
</para>





<para id="p1135">
The first statement in the 

<emphasis id="strong1146" effect="bold">
runIt

</emphasis>
 method in 

<link id="a1071" target-id="Listing_8">

Listing 8

</link>

 attempts to add a 
new element to the 

<emphasis id="strong1147" effect="bold">
ArrayList 

</emphasis>
object. The new element is a reference 
to a literal 

<emphasis id="strong1148" effect="bold">
String

</emphasis>
 object that encapsulates the string "abcd". 
This results in the compiler error shown in 

<link id="a1072" target-id="Figure_4">

Figure 4

</link>

.

</para>




	

<table id="table1003" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Figure_4" effect="bold">

Figure 4

</emphasis>

 - A compiler error.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">



<code id="pre1003" display="block">
Generics04.java:34: error: no suitable method found for add(String)
    var1.add("abcd");
        ^
    method ArrayList.add(int,Date) is not applicable
      (actual and formal argument lists differ in length)
    method ArrayList.add(Date) is not applicable
      (actual argument String cannot be converted to Date by method invocation 
      conversion)
1 error
</code>



							

</entry>

						

</row>

					

</tbody>


				

</tgroup>
</table>


	

<para id="p1136">
Without the use of generics, a reference to an object of any type could 
	be added to the collection. This could result in a runtime error later 
	if the programmer expected an object of type 

<emphasis id="strong1149" effect="bold">
Date

</emphasis>
 when in fact the 
	object is of type 

<emphasis id="strong1150" effect="bold">
String

</emphasis>
. If you are going to write programs 
	containing errors, compiler errors are almost always preferable to runtime 
	errors.

</para>









</section>
<section id="h21006">
<title>
<emphasis id="Generic_iterator_syntax_and_the_enhanced_for_loop" effect="bold">

Generic iterator syntax and the enhanced for loop

</emphasis>


</title>




<para id="p1137">
<emphasis id="strong1151" effect="bold">
Iterators

</emphasis>
</para>





<para id="p1138">
<link id="a1073" target-id="Listing_7">

Listing 7

</link>

 and 

<link id="a1074" target-id="Listing_8">

Listing 8

</link>

 showed the syntax that you must use to cause a 
collection object to be treated as a generic collection. You must also use 
a special syntax when working with generic iterators and the Java Collections 
Framework.

</para>





<para id="p1139">
<emphasis id="strong1152" effect="bold">
The enhanced for loop

</emphasis>
</para>





<para id="p1140">
Another new feature of Java version 1.5, referred to by Oracle as an 

<emphasis id="em1034" effect="italics">
enhanced 


<emphasis id="strong1153" effect="bold">
for

</emphasis>
 
loop,

</emphasis>
 can be used in certain situations to provide most of the benefits of an 
iterator with a somewhat simpler syntax. 

</para>





<note id="note1012" type="">



	

<para id="p1141">
<emphasis id="em1035" effect="italics">
(The enhanced for loop is also sometimes referred to as a for-each 
	loop.)

</emphasis>
</para>





</note>






<para id="p1142">
The program named 

<emphasis id="strong1154" effect="bold">
Generics05

</emphasis>
, which begins in 

<link id="a1075" target-id="Listing_1">

Listing 1

</link>

, illustrates 
both of these concepts. A complete listing of the program is provided in 


<link id="a1076" target-id="Listing_9">

Listing 9

</link>

.

</para>




	

<table id="table1004" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

 - Beginning of the program 
				named Generics05.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">



<code id="pre1004" display="block">
import java.util.*;

public class Generics05{
  //Create an ArrayList object suitable for
  // storing references to Date objects.
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>





<para id="p1143">
<emphasis id="strong1155" effect="bold">
The main method

</emphasis>
</para>





<para id="p1144">
As in the previous programs, the 

<emphasis id="strong1156" effect="bold">
main

</emphasis>
 method instantiates an object of 
the 

<emphasis id="strong1157" effect="bold">
Generics05

</emphasis>
 class and calls the 

<emphasis id="strong1158" effect="bold">
runIt

</emphasis>
 method on that object. 
You can view the 

<emphasis id="strong1159" effect="bold">
main

</emphasis>
 method in 

<link id="a1077" target-id="Listing_9">

Listing 9

</link>

 near the end of the module.

</para>





<para id="p1145">
<emphasis id="strong1160" effect="bold">
Instantiate a generic ArrayList object

</emphasis>
</para>





<para id="p1146">
This program is a little longer than the previous programs, so I will break 
it down and explain it in fragments.

</para>





<para id="p1147">
<link id="a1078" target-id="Listing_1">

Listing 1

</link>

 shows the beginning of the 

<emphasis id="strong1161" effect="bold">
Generics05

</emphasis>
 class. The code 
in 

<link id="a1079" target-id="Listing_1">

Listing 1

</link>

 instantiates a new 

<emphasis id="strong1162" effect="bold">
ArrayList

</emphasis>
 object capable of storing 
references to objects of type 

<emphasis id="strong1163" effect="bold">
Date

</emphasis>
 only. The code in 

<link id="a1080" target-id="Listing_1">

Listing 1

</link>

 also 
saves that object's reference in a generic instance variable named 

<emphasis id="strong1164" effect="bold">
var1

</emphasis>
. 
This is the same syntax that you have seen in previous listings.

</para>






<para id="p1148">
<emphasis id="strong1165" effect="bold">
Populate the collection

</emphasis>
</para>





<para id="p1149">
<link id="a1081" target-id="Listing_2">

Listing 2

</link>

 shows the beginning of the 

<emphasis id="strong1166" effect="bold">
runIt

</emphasis>
 method. This code 
populates the 

<emphasis id="strong1167" effect="bold">
ArrayList

</emphasis>
 object with references to three 

<emphasis id="strong1168" effect="bold">
Date

</emphasis>
 
objects. The first object encapsulates the current date and time. 
The second object encapsulates the date and time one day later than the first. 
The third object encapsulates the date and time two days later than the first 
object.

</para>




	

<table id="table1005" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">

				

<entry id="th1005">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

 - Beginning of the runIt 
				method.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">



<code id="pre1005" display="block">
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the ArrayList object
    var1.add(new Date(now));
    var1.add(new Date(now + oneDay));
    var1.add(new Date(now + 2 * oneDay));</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1150">
The code in 

<link id="a1082" target-id="Listing_2">

Listing 2

</link>

 is straightforward and shouldn't require further 
explanation.

</para>





<para id="p1151">
<emphasis id="strong1169" effect="bold">
Get and use an iterator

</emphasis>
</para>





<para id="p1152">
An iterator is an object instantiated from a specially designed class that 
implements the 

<emphasis id="strong1170" effect="bold">
Iterator

</emphasis>
 interface. The design of the class makes it 
possible for client code to gain sequential access to each element encapsulated 
in an associated collection object without a requirement to know anything about 
how the collection is structured.

</para>






<para id="p1153">
<emphasis id="strong1171" effect="bold">
Required syntax

</emphasis>
</para>





<para id="p1154">
The first statement in 

<link id="a1083" target-id="Listing_3">

Listing 3

</link>

 shows the syntax required to get and save a 
reference to a generic iterator for the 

<emphasis id="strong1172" effect="bold">
ArrayList

</emphasis>
 object instantiated 
earlier in 

<link id="a1084" target-id="Listing_1">

Listing 1

</link>

.

</para>




	

<table id="table1006" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">

				

<entry id="th1006">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

 - An iterator.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">



<code id="pre1006" display="block">
    //Get an iterator
    Iterator &lt;Date&gt; iter = var1.iterator();
    
    //Perform the iteration
    while(iter.hasNext()){
      System.out.println(iter.next().getTime());

    }//end while loop
    
    System.out.println();//blank line</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1155">
Note the requirement to qualify the declaration of the local variable named


<emphasis id="strong1173" effect="bold">
iter

</emphasis>
 with the type of data stored in the collection using angle-bracket 
notation similar to that used earlier.. You might think of this as a variable capable of holding a 
reference to an iterator object, which is capable of iterating on an 

<emphasis id="strong1174" effect="bold">

ArrayList

</emphasis>
 
object, which in turn is capable of storing references to objects of type 

<emphasis id="strong1175" effect="bold">

Date

</emphasis>
 only.

</para>





<para id="p1156">
<emphasis id="strong1176" effect="bold">
Perform the iteration

</emphasis>
</para>






<para id="p1157">
The remaining code in 

<link id="a1085" target-id="Listing_3">

Listing 3

</link>

 uses the iterator to 
sequentially access and display information encapsulated in each of the three

<emphasis id="strong1177" effect="bold">
 Date 

</emphasis>
objects whose 
references are stored in the 

<emphasis id="strong1178" effect="bold">
ArrayList

</emphasis>
 object. This is standard 
code for the use of an iterator and should not require further explanation. 
This code produces the first three lines of text 

<emphasis id="em1036" effect="italics">
(plus the blank line)

</emphasis>
 
shown in 

<link id="a1086" target-id="Figure_5">

Figure 5

</link>

.

</para>




	

<table id="table1007" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">

				

<entry id="th1007">
<emphasis id="Figure_5" effect="bold">

Figure 5

</emphasis>

 - Iterator output.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">



<code id="pre1007" display="block">
1378070280877
1378156680877
1378243080877

1378070280877
1378156680877
1378243080877</code>



							

</entry>

						

</row>

					

</tbody>


				

</tgroup>
</table>




<para id="p1158">
<emphasis id="strong1179" effect="bold">
The program output

</emphasis>
</para>







<para id="p1159">
The output produced by this program depends on when you run it. The 
output produced for one particular run is shown in 

<link id="a1087" target-id="Figure_5">

Figure 5

</link>

.

</para>





<para id="p1160">
The output will be different each time you run the program depending on the 
current date and time.

</para>





<para id="p1161">
<emphasis id="strong1180" effect="bold">
The enhanced for loop

</emphasis>
</para>





<para id="p1162">
The code in 

<link id="a1088" target-id="Listing_4">

Listing 4

</link>

 performs the same iteration using the new enhanced 

<emphasis id="strong1181" effect="bold">

for

</emphasis>
 loop that was released in Java version 1.5.

</para>




	

<table id="table1008" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">

				

<entry id="th1008">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

 - Enhanced for loop.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">



<code id="pre1008" display="block">
    //Now perform the same iteration using 
    // the new for-each construct.
    for(Date element : var1){
      System.out.println(element.getTime());
    }//end for-each

  }//end runIt</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1163">
You might think of this syntax as meaning:

</para>





<note id="note1013" type="">



	

<para id="p1164">
<emphasis id="em1037" effect="italics">
For each element of type 

<emphasis id="strong1182" effect="bold">
Date

</emphasis>
 contained in the collection 
	referred to by 

<emphasis id="strong1183" effect="bold">
var1

</emphasis>
, get the value of the element and save it in the 
	variable named

<emphasis id="strong1184" effect="bold">
 element

</emphasis>
. Then use the contents of that variable 
	to perform the operations specified within the body of the loop.

</emphasis>
<emphasis id="strong1185" effect="bold">

	

</emphasis>
</para>





</note>






<para id="p1165">
<emphasis id="strong1186" effect="bold">
More compact syntax

</emphasis>
</para>





<para id="p1166">
As you can see, this approach does not require you to get an iterator and to 
explicitly use that iterator to sequentially access the elements in the 
collection. Thus, the syntax is more compact than the syntax shown in 


<link id="a1089" target-id="Listing_3">

Listing 3

</link>

. Further, by eliminating the requirement to get the iterator, 
this construct also eliminates the requirement for you to qualify the code using 
the angle-bracket 
syntax. All of those details are handled automatically behind the scenes.

</para>





<para id="p1167">
<emphasis id="strong1187" effect="bold">
Not quite as powerful as an iterator

</emphasis>
</para>





<para id="p1168">
Although not shown in 

<link id="a1090" target-id="Listing_3">

Listing 3

</link>

, the use of an iterator allows you to remove 
the most recently accessed element from a collection. As near as I can 
tell, the enhanced 

<emphasis id="strong1188" effect="bold">
for

</emphasis>
 loop does not provide that capability. 
Therefore, the enhanced 

<emphasis id="strong1189" effect="bold">
for

</emphasis>
 loop is not quite as powerful as an iterator. 
However, if you don't need to remove elements from the collection, the enhanced


<emphasis id="strong1190" effect="bold">
for

</emphasis>
 loop appears to be a good and somewhat simpler alternative to an 
iterator.

</para>





<para id="p1169">
<emphasis id="strong1191" effect="bold">
The output

</emphasis>
</para>





<para id="p1170">
The code in 

<link id="a1091" target-id="Listing_4">

Listing 4

</link>

 produced the last three lines of text in the output 
shown in 

<link id="a1092" target-id="Figure_5">

Figure 5

</link>

. Obviously the last three lines match the first three 
lines since they simply represent different ways to produce a text 
representation of the same three 

<emphasis id="strong1192" effect="bold">
Date

</emphasis>
 objects.

</para>






</section>
</section>
<section id="h11005">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>





<para id="p1171">
I encourage you to copy the code from 

<link id="a1093" target-id="Listing_5">

Listing 5

</link>

 through 

<link id="a1094" target-id="Listing_9">

Listing 9

</link>

 Compile the code and 
execute it. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>



	

</section>
<section id="h11006">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1172">
In this module, I explained:

</para>





<list id="ul1011" list-type="bulleted">

	

<item id="li1054">
How the Java Collections Framework behaved prior to the release of Java 
	version 1.5.

</item>


	

<item id="li1055">
The effect of an incorrect cast in code that doesn't use generics.

</item>


	

<item id="li1056">
How to avoid the requirement to cast through the use of generics, 
	including an illustration of some of the required syntax for generics.

</item>


	

<item id="li1057">
The compile-time type safety provided by the use of generics.

</item>


	

<item id="li1058">
The syntax requirements for the use of iterators with generics.

</item>


	

<item id="li1059">
The use of the enhanced 

<emphasis id="strong1193" effect="bold">
for

</emphasis>
 loop with collections.

</item>




</list>




</section>
<section id="h11007">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1173">
Future modules in this series will be based on the


<link id="a1095" url="http://docs.oracle.com/javase/tutorial/java/generics/">

Generics 
(Updated)

</link>

 section of


<link id="a1096" url="http://docs.oracle.com/javase/tutorial/index.html">

The Java Tutorials

</link>

 
from Oracle. 

<emphasis id="em1038" effect="italics">
(In the event that these links become broken, you should have 
no difficulty finding the Oracle material with an online search.)

</emphasis>
</para>





<para id="p1174">
Those modules will teach you about other aspects of generics 
including:

</para>





<list id="ul1012" list-type="bulleted">

	

<item id="li1060">
Generic methods

</item>


	

<item id="li1061">
Generic classes

</item>


	

<item id="li1062">
Raw types in generics

</item>


	

<item id="li1063">
Wildcards and bounded wildcards in generics

</item>


	

<item id="li1064">
The impact of inheritance on generics

</item>




</list>


	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1175">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1014" type="">


		


			


				

<emphasis id="strong1194" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1013" list-type="bulleted">

					

<item id="li1065">
Module name: Getting Started with Generics

</item>


					

<item id="li1066">
File: Java4210.htm 

</item>


					

<item id="li1067">
Published: 09/01/2013

</item>


				

</list>


				

</note>

			


		



	





	

<note id="note1015" type="">


		


			


				

<emphasis id="strong1195" effect="bold">
Disclaimers:

</emphasis>
<para id="p1176">
<emphasis id="strong1196" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1177">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1178">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1179">
<emphasis id="strong1197" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>



				

</note>

			


		



	





</section>
<section id="h11009">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1180">
Complete listings of the programs discussed in this module are provided 
below.

</para>





<note id="note1016" type="">





<para id="p1181">
<emphasis id="strong1198" effect="bold">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

 - The program named 
				Generics01.

</emphasis>
</para>






<code id="pre1009" display="block">
/*File Generics01.java 
Copyright 2005, R.G.Baldwin

Illustrates requirement to cast without the use 
of generics.

V1.5 compiler produces following warning:

Note: Generics01.java uses unchecked or unsafe 
operations.
Note: Recompile with -Xlint:unchecked for 
details.

Recompilation with -Xlint:unchecked produces 
the following output:

Generics01.java:34: warning: [unchecked] unchecked
call to add(E) as a member of
 the raw type ArrayList
    var1.add(new Date());
            ^
  where E is a type-variable:
    E extends Object declared in class ArrayList
1 warning

Tested using JDK 1.7 under Win 7.
************************************************/

import java.util.*;

public class Generics01{
  
  ArrayList var1 = new ArrayList();

  void runIt(){
    var1.add(new Date());
    //Note the required cast in the following
    // statement.
    System.out.println(
                  ((Date)var1.get(0)).getTime());
  }//runIt

  public static void main(String[] args){
    new Generics01().runIt();
  }//end main
  
}//end class Generics01
//=============================================//
</code>




</note>







<note id="note1017" type="">





<para id="p1182">
<emphasis id="strong1199" effect="bold">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

 - The program named 
				Generics02.

</emphasis>
</para>






<code id="pre1010" display="block">
/*File Generics02.java 
Copyright 2005, R.G.Baldwin

Illustrates the application of an incorrect cast 
to an element that is fetched from an ArrayList 
object and the runtime error produced by that
incorrect cast.

This program does not produce a compiler error, 
although the v1.5 compiler does produce a 
general warning having to do with the failure 
to apply the new generics syntax released in 
v1.5. (Earlier compilers would not have produced
such a warning.)

However, the compiler does not check to confirm 
that the correct cast is applied.  This results 
in the following runtime error when an incorrect 
cast is applied:

Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot
 be cast to java.util.Date
        at Generics02.runIt(Generics02.java:46)
        at Generics02.main(Generics02.java:53)


Tested using JDK 1.7 under Win 7.
************************************************/

import java.util.*;

public class Generics02{
  
  ArrayList var1 = new ArrayList();
  
  void runIt(){
    var1.add(new Date());
    var1.add("abcd");
    //Note that the (Date) cast is applied to 
    // an element of type String in the following
    // statement, producing a runtime error.  The
    // problem is that the wrong index was used
    // in fetching the element.  Thus, the wrong
    // element was fetched.
    System.out.println(
                  ((Date)var1.get(1)).getTime());
    System.out.println(
                 ((String)var1.get(1)).length());
  }//end runIt

  public static void main(String[] args){
    new Generics02().runIt();
  }//end main
  
}//end class Generics02
//=============================================//
</code>







</note>




	

<table id="table1009" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1009">

			

<row id="tr1018">

				

<entry id="th1009">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

 - The program named 
				Generics03.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1009">

			

<row id="tr1019">

				

<entry id="td1009">



<code id="pre1011" display="block">
/*File Generics03.java 
Copyright 2005, R.G.Baldwin

Illustrates use of generics to avoid requirement 
to cast.  Requires v1.5 or later.

Program output for one run was:

1377995720768

Tested using JDK 1.7 under Win 7.
************************************************/

import java.util.*;

public class Generics03{
  
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();

  void runIt(){
    var1.add(new Date());
    //Note that no cast is required in the
    // following statement.
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics03().runIt();
  }//end main
  
}//end class Generics03
//=============================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>





	

<table id="table1010" summary="A table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1010">

			

<row id="tr1020">

				

<entry id="th1010">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

 - The program named 
				Generics04.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1010">

			

<row id="tr1021">

				

<entry id="td1010">



<code id="pre1012" display="block">
/*File Generics04.java 
Copyright 2005, R.G.Baldwin

Illustrates ability of generics to prevent 
storing of wrong type in a collection.  
Requires v1.5 or later.

Compilation produces following error message:

Generics04.java:34: error: no suitable method 
found for add(String)
    var1.add("abcd");
        ^
    method ArrayList.add(int,Date) is not 
    applicable (actual and formal argument lists 
    differ in length)
    method ArrayList.add(Date) is not applicable
      (actual argument String cannot be converted 
      to Date by method invocation conversion)
1 error

Once the ArrayList has been declared to be of
type Date, it is not possible to add an element
of type String.  An attempt to do so produces
a compiler error.

Tested using JDK 1.7 under Win 7.
************************************************/

import java.util.*;

public class Generics04{
  
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();
  
  void runIt(){
    var1.add("abcd");
    System.out.println(var1.get(0).getTime());
  }//end runIt

  public static void main(String[] args){
    new Generics04().runIt();
  }//end main

}//end class Generics04
//=============================================//
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>





<note id="note1018" type="">





<para id="p1183">
<emphasis id="strong1200" effect="bold">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

 - The program named 
				Generics05.

</emphasis>
</para>






<code id="pre1013" display="block">
/*File Generics05.java 
Copyright 2005, R.G.Baldwin

Illustrates required syntax for using an iterator
with generics.  Also illustrates the new for-each
construct in Java 5.0

Output for one particular run is shown below.

1378070280877
1378156680877
1378243080877

1378070280877
1378156680877
1378243080877

Output will be different each time the program
is run depending on the current date and time.

Tested using JDK 1.7 under Win 7.
************************************************/

import java.util.*;

public class Generics05{
  //Create an ArrayList object suitable for
  // storing references to Date objects.
  ArrayList &lt;Date&gt; var1 = new ArrayList&lt;Date&gt;();
  
  void runIt(){
    //Get current date and time in milliseconds.
    long now = new Date().getTime();
    //Get length of one day in milliseconds
    long oneDay = 24 * 60 * 60 * 1000;

    //Populate the ArrayList object
    var1.add(new Date(now));
    var1.add(new Date(now + oneDay));
    var1.add(new Date(now + 2 * oneDay));

    //Get an iterator
    Iterator &lt;Date&gt; iter = var1.iterator();
    
    //Perform the iteration
    while(iter.hasNext()){
      System.out.println(iter.next().getTime());

    }//end while loop
    
    System.out.println();//blank line
    
    //Now perform the same iteration using 
    // the new for-each construct.
    for(Date element : var1){
      System.out.println(element.getTime());

    }//end for-each

  }//end runIt

  public static void main(String[] args){
    new Generics05().runIt();
  }//end main

}//end class Generics05
//=============================================//
</code>




</note>






<para id="p1184">
-end- 

</para>







</section>
</content>




</document>