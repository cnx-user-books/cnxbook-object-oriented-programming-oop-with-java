<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java1616: Polymorphism and Interfaces, Part 1</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m44195</md:content-id>
  <md:title>Java1616: Polymorphism and Interfaces, Part 1</md:title>
  <md:abstract>According to Baldwin, if you don't understand the Java interface, you don't understand Java.  There is very little, if anything useful that can be done using Java without understanding and using the Java interface.</md:abstract>
  <md:uuid>2c050ae1-4c10-4941-9123-b15ad8730c35</md:uuid>
</metadata>

<content>






<para id="p1000">
Revised: Thu Mar 31 14:33:41 CDT 2016

</para>




<para id="p1001">
<emphasis id="em1000" effect="italics">
This page is included in the following Books:

</emphasis>
</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">

	

<link id="a1000" url="http://cnx.org/contents/dzOvxPFw">


<emphasis id="em1001" effect="italics">
ITSE 2321 - Object-Oriented Programming (Java)

</emphasis>
</link>


</item>


	

<item id="li1001">

	

<link id="a1001" url="http://cnx.org/contents/-2RmHFs_">


<emphasis id="em1002" effect="italics">
Object-Oriented Programming (OOP) with Java 
	

</emphasis>
 
	

</link>

 

</item>




</list>














<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1001" list-type="bulleted">

	

<item id="li1002">
<link id="a1002" target-id="Preface">

Preface

</link>


	

<list id="ul1002" list-type="bulleted">

		

<item id="li1003">
<link id="a1003" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1003" list-type="bulleted">

			

<item id="li1004">
<link id="a1004" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1005">
<link id="a1005" target-id="Preview">

Preview

</link>

 

</item>


	

<item id="li1006">
<link id="a1006" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


</item>


	

<item id="li1007">
<link id="a1007" target-id="Summary">

Summary

</link>

 

</item>


	

<item id="li1008">
<link id="a1008" target-id="Whats_next">

What's next?

</link>


</item>


	

<item id="li1009">
<link id="a1009" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1010">
<link id="a1010" target-id="Complete_program_listing">

Complete program listings

</link>


</item>




</list>


	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
This module is one of a series of modules designed to teach you about the essence of Object-Oriented Programming (OOP) using Java.

</para>



	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1003">
I recommend that you open another copy of this document in a separate 
browser window and use the following links to easily find and view the listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1004" list-type="bulleted">

		

<item id="li1011">
<link id="a1011" target-id="Listing_1">

Listing 1

</link>

. Definition of interfaces named I1 and I2.

</item>


		

<item id="li1012">
<link id="a1012" target-id="Listing_2">

Listing 2

</link>

. Definition of the class named A. 

</item>


		

<item id="li1013">
<link id="a1013" target-id="Listing_3">

Listing 3

</link>

. Definition of the class named B. 

</item>


		

<item id="li1014">
<link id="a1014" target-id="Listing_4">

Listing 4

</link>

. Definition of the class named C. 

</item>


		

<item id="li1015">
<link id="a1015" target-id="Listing_5">

Listing 5

</link>

. The driver class named Poly05.

</item>


		

<item id="li1016">
<link id="a1016" target-id="Listing_6">

Listing 6

</link>

. Complete program listing.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>


	

<para id="p1004">
<emphasis id="strong1000" effect="bold">
Method overloading

</emphasis>
 

</para>





<para id="p1005">
I covered method overloading as one form of polymorphism 

<emphasis id="em1003" effect="italics">
(compile-time polymorphism)

</emphasis>
 in a previous module.  I also explained automatic type conversion and the use of the cast operator for type conversion in a previous module. 

</para>





<para id="p1006">
<emphasis id="strong1001" effect="bold">
Method overriding and class inheritance

</emphasis>
 

</para>





<para id="p1007">
I also discussed runtime polymorphism implemented through method overriding and class inheritance in previous modules.



</para>





<para id="p1008">
<emphasis id="strong1002" effect="bold">
Using the Java interface

</emphasis>
 

</para>





<para id="p1009">
In this module and the next, I will explain runtime polymorphism as implemented using method overriding and the Java interface.



</para>





<para id="p1010">
<emphasis id="strong1003" effect="bold">
A very important concept

</emphasis>
 

</para>





<para id="p1011">
In my opinion, this is one of the most important concepts in Java OOP, and the one that seems to give students the greatest amount of difficulty.  Therefore, I will try to take it slow and easy.  As usual, I will illustrate the concept using sample programs.



</para>





<para id="p1012">
I will also tie this concept back to the concept of polymorphism using method overriding through inheritance.



</para>





<para id="p1013">
<emphasis id="strong1004" effect="bold">
A skeleton program



</emphasis>
 

</para>





<para id="p1014">
In this module, I will present a simple skeleton program that illustrates many of the important aspects of polymorphic behavior based on the Java interface.



</para>





<para id="p1015">
<emphasis id="strong1005" effect="bold">
Multiple inheritance and the cardinal rule

</emphasis>
 

</para>





<para id="p1016">
I will explain how the implementation of interfaces in Java is similar to multiple inheritance.

I will explain the cardinal rule of interface implementation.



</para>





<para id="p1017">
<emphasis id="strong1006" effect="bold">
A new relationship

</emphasis>
 

</para>





<para id="p1018">
I will explain that objects instantiated from classes that implement the same interface have a new relationship that goes beyond the relationship imposed by the standard class hierarchy.



</para>





<para id="p1019">
<emphasis id="strong1007" effect="bold">
One object, many types

</emphasis>
 

</para>





<para id="p1020">
I will explain that due to the combination of the class hierarchy and the fact that a class can implement many different interfaces, a single object in Java can be treated as many different types.  However, for any given type, there are restrictions on the methods that can be called on the object.



</para>





<para id="p1021">
<emphasis id="strong1008" effect="bold">
Many classes, one type

</emphasis>
 

</para>





<para id="p1022">
I will explain that because different classes can implement the same interface, objects instantiated from different classes can be treated as a common interface type.



</para>





<para id="p1023">
<emphasis id="strong1009" effect="bold">
Interfaces are critical to Java programming

</emphasis>
 

</para>





<para id="p1024">
I will suggest that there is little if anything useful that can be done in Java without understanding and using interfaces. 

</para>





<para id="p1025">
In support of this suggestion, I will discuss several real-world examples of the use of the Java interface, including the Delegation Event Model, 
the Model View Control paradigm, and iterators in Java data structures.

</para>



	
	

</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	
	

<para id="p1026">
<link id="a1017" target-id="Listing_6">

Listing 6

</link>

 near the end of the module contains a very simple program named 
	

<emphasis id="strong1010" effect="bold">
Poly05

</emphasis>
.



</para>





<para id="p1027">
The purpose of this program is to illustrate polymorphic behavior using interfaces in addition to class inheritance.



</para>





<para id="p1028">
<emphasis id="strong1011" effect="bold">
Designed to illustrate structure

</emphasis>
 

</para>





<para id="p1029">
This is a skeleton program designed solely to illustrate the inheritance and interface implementation structure in as simple a program as possible.


<emphasis id="em1004" effect="italics">
(I will put some meat on this skeleton using another program in the next module.)

</emphasis>
</para>





<para id="p1030">
<emphasis id="strong1012" effect="bold">
Empty methods

</emphasis>
 

</para>





<para id="p1031">
Except for the two methods that return type 

<emphasis id="strong1013" effect="bold">
String

</emphasis>
, all of the methods in the program are empty.  


<emphasis id="em1005" effect="italics">
(Methods that return type 

<emphasis id="strong1014" effect="bold">
String

</emphasis>
 cannot be empty.  They must contain a 


<emphasis id="strong1015" effect="bold">
return

</emphasis>
 statement in order to compile successfully.)


</emphasis>
 

</para>





<para id="p1032">
<emphasis id="strong1016" effect="bold">
Interface definitions

</emphasis>
 

</para>





<para id="p1033">
<link id="a1018" target-id="Listing_1">

Listing 1

</link>

 shows the definition of two simple interfaces named 


<emphasis id="strong1017" effect="bold">
I1

</emphasis>
 and 

<emphasis id="strong1018" effect="bold">
I2

</emphasis>
. 

</para>



	

<table id="table1000" summary="A table." pgwide="0">
<tgroup cols="1">


		

<thead id="thead1000">

			

<row id="tr1000">

				

<entry id="th1000">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Definition of interfaces 
				named I1 and I2.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1000">

			

<row id="tr1001">

				

<entry id="td1000">

				

<code id="pre1000" display="block">interface I1{
  public void p();
}//end interface I1

//===================================//

interface I2 extends I1{
  public void q();
}//end interface I2</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1034">
<emphasis id="strong1019" effect="bold">
Similar but different



</emphasis>
 

</para>





<para id="p1035">
An interface definition is similar to a class definition.  However, there are some very important differences.



</para>





<para id="p1036">
<emphasis id="strong1020" effect="bold">
No single hierarchy



</emphasis>
 

</para>





<para id="p1037">
To begin with, unlike the case with classes, there is no single interface hierarchy.  Also, multiple inheritance is allowed when extending interfaces.



</para>





<para id="p1038">
A new interface can extend none, one, or more existing interfaces.  In 

<link id="a1019" target-id="Listing_1">

Listing 1

</link>

,


<emphasis id="strong1021" effect="bold">
I2

</emphasis>
 extends 

<emphasis id="strong1022" effect="bold">
I1

</emphasis>
, but 

<emphasis id="strong1023" effect="bold">
I1

</emphasis>
 doesn't extend any other interface 


<emphasis id="em1006" effect="italics">
(and unlike classes, an interface doesn't automatically extend another interface by default)

</emphasis>
. 

</para>





<para id="p1039">
<emphasis id="strong1024" effect="bold">
Two kinds of members allowed



</emphasis>
 

</para>





<para id="p1040">
Only two kinds of members are allowed in an interface definition:

    

</para>





<list id="ul1005" list-type="bulleted">

	

<item id="li1017">
Methods, which are implicitly abstract
    

</item>


	

<item id="li1018">
Variables, which are implicitly constant 

<emphasis id="em1007" effect="italics">
(final) 

</emphasis>
</item>




</list>




<para id="p1041">
Each of the interfaces in 

<link id="a1020" target-id="Listing_1">

Listing 1

</link>

 declares an implicitly abstract method 


<emphasis id="em1008" effect="italics">
(an abstract method does not have a body)

</emphasis>
. 

</para>





<para id="p1042">
Neither of the interfaces in 

<link id="a1021" target-id="Listing_1">

Listing 1

</link>

 declares any variables 


<emphasis id="em1009" effect="italics">
(they aren't needed for the purpose of this module)

</emphasis>
. 

</para>





<para id="p1043">
<emphasis id="strong1025" effect="bold">
A new data type



</emphasis>
 

</para>





<para id="p1044">
I told you earlier that when you define a new class, you cause a new data type to become available to your program.  The same is true of an interface definition.  Each interface definition constitutes a new type.



</para>





<para id="p1045">
<emphasis id="strong1026" effect="bold">
The class named A

</emphasis>
 

</para>





<para id="p1046">
<link id="a1022" target-id="Listing_2">

Listing 2

</link>

 defines a very simple class named 

<emphasis id="strong1027" effect="bold">
A

</emphasis>
, which in turn defines two methods named 


<emphasis id="strong1028" effect="bold">
toString

</emphasis>
 and 

<emphasis id="strong1029" effect="bold">
x

</emphasis>
. 

</para>



	

<table id="table1001" summary="A table." pgwide="0">
<tgroup cols="1">


		

<thead id="thead1001">

			

<row id="tr1002">

				

<entry id="th1001">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Definition of the class 
				named A.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1001">

			

<row id="tr1003">

				

<entry id="td1001">

				

<code id="pre1001" display="block">class A extends Object{
  public String toString(){
    return "toString in A";
  }//end toString()
  //---------------------------------//
  
  public String x(){
    return "x in A";
  }//end x()
  //---------------------------------//
}//end class A</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1047">
<emphasis id="strong1030" effect="bold">
Overridden toString

</emphasis>
 

</para>





<para id="p1048">
The method named 

<emphasis id="strong1031" effect="bold">
toString

</emphasis>
 in 

<link id="a1023" target-id="Listing_2">

Listing 2

</link>

 is actually an overridden version of the method having the same name that is defined in the class named 


<emphasis id="strong1032" effect="bold">
Object

</emphasis>
.  

<emphasis id="em1010" effect="italics">
(Recall that a previous module made heavy use of overridden versions of the 


<emphasis id="strong1033" effect="bold">
toString

</emphasis>
 method.) 

</emphasis>
 

</para>





<para id="p1049">
<emphasis id="strong1034" effect="bold">
New method



</emphasis>
 

</para>





<para id="p1050">
The method named 

<emphasis id="strong1035" effect="bold">
x

</emphasis>
 is newly defined in the class named 


<emphasis id="strong1036" effect="bold">
A

</emphasis>
. 

<emphasis id="em1011" effect="italics">
(The method named 

</emphasis>
<emphasis id="strong1037" effect="bold">
<emphasis id="em1012" effect="italics">
x

</emphasis>
</emphasis>
<emphasis id="em1013" effect="italics">
 is not inherited into the class named 


</emphasis>
<emphasis id="strong1038" effect="bold">
<emphasis id="em1014" effect="italics">
A

</emphasis>
</emphasis>
<emphasis id="em1015" effect="italics">
, because the class named 

<emphasis id="strong1039" effect="bold">
Object

</emphasis>
 does not define a method named 


<emphasis id="strong1040" effect="bold">
x

</emphasis>
.) 

</emphasis>
 

</para>





<para id="p1051">
<emphasis id="strong1041" effect="bold">
The class named B

</emphasis>
 

</para>





<para id="p1052">
<link id="a1024" target-id="Listing_3">

Listing 3

</link>

 contains material that is new to this module. 

</para>



	

<table id="table1002" summary="A table." pgwide="0">
<tgroup cols="1">


		

<thead id="thead1002">

			

<row id="tr1004">

				

<entry id="th1002">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Definition of the class 
				named B.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1002">

			

<row id="tr1005">

				

<entry id="td1002">

				

<code id="pre1002" display="block">class B extends A implements I2{
  public void p(){
  }//end p()
  //---------------------------------//
  
  public void q(){
  }//end q();
  //---------------------------------//
}//end class B</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1053">
<emphasis id="strong1042" effect="bold">
Implementing an interface

</emphasis>
 

</para>





<para id="p1054">
<link id="a1025" target-id="Listing_3">

Listing 3

</link>

 defines a class named 

<emphasis id="strong1043" effect="bold">
B

</emphasis>
, which 


<emphasis id="em1016" effect="italics">
extends

</emphasis>
 the class named 

<emphasis id="strong1044" effect="bold">
A

</emphasis>
, and 

<emphasis id="em1017" effect="italics">
implements

</emphasis>
 the interface named 


<emphasis id="strong1045" effect="bold">
I2

</emphasis>
.



</para>





<para id="p1055">
As you already know, a class in Java can extend only one other class.  However, a Java class can implement any number of interfaces. 


<emphasis id="em1018" effect="italics">
(Multiple inheritance is allowed with interfaces.) 

</emphasis>




</para>





<para id="p1056">
<emphasis id="strong1046" effect="bold">
Similar to an abstract class

</emphasis>




</para>





<para id="p1057">
An interface is similar, but not identical, to an 

<emphasis id="strong1047" effect="bold">
abstract

</emphasis>
 class.

    

<emphasis id="em1019" effect="italics">
(An abstract class may contain abstract methods or concrete methods, or a combination of the two 
while all of the methods in an interface are implicitly abstract.)

</emphasis>
</para>





<para id="p1058">
<emphasis id="strong1048" effect="bold">
Restrictions

</emphasis>
</para>





<para id="p1059">
An abstract class cannot be instantiated. Thus, an abstract class is only 
useful when it is extended by another class.

</para>





<para id="p1060">
An interface also cannot be instantiated.

</para>





<para id="p1061">
<emphasis id="strong1049" effect="bold">
Implicitly abstract methods

</emphasis>
</para>





<para id="p1062">
As mentioned above, all methods declared in an interface are implicitly abstract, but that is not true for an abstract class.  An abstract class can also contain fully-defined 


<emphasis id="em1020" effect="italics">
(concrete)

</emphasis>
 methods. Regardless, an abstract class cannot be 
instantiated.

</para>





<para id="p1063">
<emphasis id="strong1050" effect="bold">
A totally abstract class



</emphasis>




</para>





<para id="p1064">
At the risk of offending the purists, I will coin a new term here and say that an interface is similar to a totally abstract class 


<emphasis id="em1021" effect="italics">
(one that contains only abstract method declarations and final variables)

</emphasis>
.



</para>





<para id="p1065">
To a first degree of approximation then, we might say that the class named 


<emphasis id="strong1051" effect="bold">
B

</emphasis>
 is not only a subclass of the class named 

<emphasis id="strong1052" effect="bold">
A

</emphasis>
, it is also a subclass of the 


<emphasis id="em1022" effect="italics">
totally abstract

</emphasis>
 class named 

<emphasis id="strong1053" effect="bold">
I2

</emphasis>
. 

<emphasis id="em1023" effect="italics">
(This is pretty far out 
with respect to terminology, so to avoid being embarrassed, you probably shouldn't repeat it to anyone else.)

</emphasis>




</para>





<para id="p1066">
Since 

<emphasis id="strong1054" effect="bold">
I2

</emphasis>
 extends 

<emphasis id="strong1055" effect="bold">
I1

</emphasis>
, we might also say that the class named 


<emphasis id="strong1056" effect="bold">
B

</emphasis>
 is a subclass of the 

<emphasis id="em1024" effect="italics">
totally abstract

</emphasis>
 class named 


<emphasis id="strong1057" effect="bold">
I1

</emphasis>
.



</para>





<para id="p1067">
<emphasis id="strong1058" effect="bold">
A different kind of thinking

</emphasis>




</para>





<para id="p1068">
With this kind of thinking, we have suddenly make it possible for Java classes to support 


<emphasis id="em1025" effect="italics">
multiple inheritance

</emphasis>
, with the stipulation that all but one of the inherited classes must be 


<emphasis id="em1026" effect="italics">
totally abstract classes

</emphasis>
.



</para>





<para id="p1069">
<emphasis id="strong1059" effect="bold">
Be very careful with this way of thinking



</emphasis>




</para>





<para id="p1070">
However, we need to be very careful with this kind of thinking.  While it may help some students to understand the role of interfaces in Java, there are probably some hidden dangers lurking here.



</para>





<para id="p1071">
<emphasis id="strong1060" effect="bold">
Back to the safety zone



</emphasis>




</para>





<para id="p1072">
The safest course of action is to simply say that the class named 

<emphasis id="strong1061" effect="bold">
B

</emphasis>
:

    

</para>





<list id="ul1006" list-type="bulleted">

	

<item id="li1019">
Extends the class named 

<emphasis id="strong1062" effect="bold">
A

</emphasis>
 

</item>


	

<item id="li1020">
Implements the interface named 

<emphasis id="strong1063" effect="bold">
I2

</emphasis>
 directly
    

</item>


	

<item id="li1021">
Implements the interface named 

<emphasis id="strong1064" effect="bold">
I1

</emphasis>
 through inheritance
	

</item>




</list>




<para id="p1073">
Java does not support multiple inheritance, but it does allow you to extend one class and implement any number of interfaces.



</para>





<para id="p1074">
<emphasis id="strong1065" effect="bold">
The cardinal rule

regarding interface implementation

</emphasis>




</para>





<para id="p1075">
The cardinal rule in implementing interfaces is:

    

</para>





<para id="p1076">
<emphasis id="em1027" effect="italics">
If a class implements an interface, it must provide a concrete definition for all the methods declared by that interface, and all the methods inherited by that interface.  Otherwise, the class must be declared abstract and the definitions must be provided by a class that extends the abstract class.

</emphasis>




</para>





<para id="p1077">
<emphasis id="strong1066" effect="bold">
The cardinal rule

regarding class inheritance

</emphasis>




</para>





<para id="p1078">
A similar rule exists for defining classes that inherit abstract methods from 
other classes:

</para>





<para id="p1079">
<emphasis id="em1028" effect="italics">
If a class inherits one or more abstract methods from its superclasses, it must provide concrete definitions 
for all the inherited abstract methods.  Otherwise, the class must be declared abstract and the 
concrete definitions must be provided by a class that extends the abstract class.

</emphasis>




</para>





<para id="p1080">
<emphasis id="strong1067" effect="bold">
What does that mean in this case?

</emphasis>




</para>





<para id="p1081">
In this case, this means that the class named 

<emphasis id="strong1068" effect="bold">
B

</emphasis>
 must provide concrete definitions for the methods named 


<emphasis id="strong1069" effect="bold">
p

</emphasis>
 and 

<emphasis id="strong1070" effect="bold">
q

</emphasis>
, because:

    

</para>





<list id="ul1007" list-type="bulleted">

	

<item id="li1022">
The class named 

<emphasis id="strong1071" effect="bold">
B

</emphasis>
 implements the interface named 
	

<emphasis id="strong1072" effect="bold">
I2

</emphasis>
.

</item>


	

<item id="li1023">
The method named 

<emphasis id="strong1073" effect="bold">
q

</emphasis>
 is declared in the interface named 
	

<emphasis id="strong1074" effect="bold">
I2

</emphasis>
.

</item>


	

<item id="li1024">
The interface named 

<emphasis id="strong1075" effect="bold">
I2

</emphasis>
 extends the interface named 
	

<emphasis id="strong1076" effect="bold">
I1

</emphasis>
.

</item>


	

<item id="li1025">
The method named 

<emphasis id="strong1077" effect="bold">
p

</emphasis>
 is declared in the interface named 
	

<emphasis id="strong1078" effect="bold">
I1

</emphasis>
. 

</item>




</list>




<para id="p1082">
As in method overriding, the signature of the concrete method in the defining class must match the signature of the method as it is declared in the interface.



</para>





<para id="p1083">
<emphasis id="strong1079" effect="bold">
Class B satisfies the cardinal rule

</emphasis>




</para>





<para id="p1084">
As you can see from 

<link id="a1026" target-id="Listing_3">

Listing 3

</link>

, the class named 


<emphasis id="strong1080" effect="bold">
B

</emphasis>
 does provide concrete 

<emphasis id="em1029" effect="italics">
(but empty)

</emphasis>
 definitions of the methods named 


<emphasis id="strong1081" effect="bold">
p

</emphasis>
 and 

<emphasis id="strong1082" effect="bold">
q

</emphasis>
.

    

</para>





<para id="p1085">
<emphasis id="em1030" effect="italics">
(As mentioned earlier, I made the methods empty in this program for simplicity.  However, it is not uncommon to define empty methods in classes that implement interfaces 
that declare a large number of methods, such as the 

</emphasis>
<emphasis id="strong1083" effect="bold">
<emphasis id="em1031" effect="italics">
MouseListener

</emphasis>
</emphasis>
<emphasis id="em1032" effect="italics">
 
interface. See my tutorials on event-driven programming


<link id="a1027" url="http://cnx.org/contents/-2RmHFs_:qfO9iJX-">

here

</link>

 for examples.) 

</emphasis>




</para>





<para id="p1086">
<emphasis id="strong1084" effect="bold">
The class named C

</emphasis>




</para>





<para id="p1087">
<link id="a1028" target-id="Listing_4">

Listing 4

</link>

 defines a class named 

<emphasis id="strong1085" effect="bold">
C

</emphasis>
, which extends 


<emphasis id="strong1086" effect="bold">
Object

</emphasis>
, and also implements 

<emphasis id="strong1087" effect="bold">
I2

</emphasis>
.  As in the case of the class named 


<emphasis id="strong1088" effect="bold">
B

</emphasis>
, this class must, and does, provide concrete 

<emphasis id="em1033" effect="italics">
(but empty)


</emphasis>
definitions for the methods named 

<emphasis id="strong1089" effect="bold">
p

</emphasis>
 and 

<emphasis id="strong1090" effect="bold">
q

</emphasis>
. 

</para>



	

<table id="table1003" summary="A table." pgwide="0">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Definition of the class 
				named C.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">

				

<code id="pre1003" display="block">class C extends Object implements I2{
  public void p(){
  }//end p()
  //---------------------------------//
  
  public void q(){
  }//end q();
  //---------------------------------//
}//end class B</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1088">
<emphasis id="strong1091" effect="bold">
A driver class

</emphasis>
 

</para>





<para id="p1089">
Finally, the driver class named 

<emphasis id="strong1092" effect="bold">
Poly05

</emphasis>
 shown in


<link id="a1029" target-id="Listing_5">

Listing 5

</link>

 defines an empty 

<emphasis id="strong1093" effect="bold">
main

</emphasis>
 method. 

</para>



	

<table id="table1004" summary="A table." pgwide="0">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. The driver class named 
				Poly05.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">

				

<code id="pre1004" display="block">public class Poly05{
  public static void main(String[] args){
  }//end main
}//end class Poly05</code>


				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>


	

<para id="p1090">
<emphasis id="strong1094" effect="bold">
Doesn't do anything



</emphasis>
 

</para>





<para id="p1091">
As mentioned earlier, the purpose of this program is solely to illustrate an inheritance and interface structure.  This program can be compiled and executed, but it doesn't do anything useful.



</para>





<para id="p1092">
<emphasis id="strong1095" effect="bold">
A new relationship



</emphasis>
 

</para>





<para id="p1093">
At this point, it might be useful for you to sketch out the structure in a simple hierarchy diagram.



</para>





<para id="p1094">
If you do, you will see that implementation of the interface named 

<emphasis id="strong1096" effect="bold">
I2

</emphasis>
 by the classes named 


<emphasis id="strong1097" effect="bold">
B

</emphasis>
 and 

<emphasis id="strong1098" effect="bold">
C

</emphasis>
, has created a relationship between those two classes that is totally independent of the normal class hierarchical relationship. 

</para>





<para id="p1095">
<emphasis id="strong1099" effect="bold">
What is the new relationship?



</emphasis>
 

</para>





<para id="p1096">
By declaring that both of these classes implement the same interface named 


<emphasis id="strong1100" effect="bold">
I2

</emphasis>
, we are guaranteeing that an object of either class will contain concrete definitions of the two methods declared in the interfaces named 


<emphasis id="strong1101" effect="bold">
I2

</emphasis>
 and 

<emphasis id="strong1102" effect="bold">
I1

</emphasis>
. 

</para>





<para id="p1097">
Furthermore, we are guaranteeing that objects instantiated from the two classes can be treated as the common type 


<emphasis id="strong1103" effect="bold">
I2

</emphasis>
. 

</para>





<para id="p1098">
<emphasis id="em1034" effect="italics">
(

</emphasis>
<emphasis id="strong1104" effect="bold">
<emphasis id="em1035" effect="italics">
Important

</emphasis>
</emphasis>
<emphasis id="em1036" effect="italics">
: references to any objects instantiated from classes that implement 


<emphasis id="strong1105" effect="bold">
I2

</emphasis>
, can be stored in reference variables of the type 

<emphasis id="strong1106" effect="bold">
I2

</emphasis>
, and any of the interface methods can be called on those references.)


</emphasis>
 

</para>





<para id="p1099">
<emphasis id="strong1107" effect="bold">
We know the user interface



</emphasis>
 

</para>





<para id="p1100">
The signatures of the interface methods in the two classes must match the signatures declared in the interfaces.



</para>





<para id="p1101">
This means that if we have access to the documentation for the interfaces, we also know the signatures of the interface methods for objects instantiated from any class that implements the interfaces.



</para>





<para id="p1102">
<emphasis id="strong1108" effect="bold">
Different behavior



</emphasis>
 

</para>





<para id="p1103">
However, and this is extremely important, the behavior of the interface methods as defined in the class named 


<emphasis id="strong1109" effect="bold">
B

</emphasis>
 may be 

<emphasis id="em1037" effect="italics">
(and often will be)

</emphasis>
 entirely different from the behavior of the interface methods having the same signatures as defined in the class named 


<emphasis id="strong1110" effect="bold">
C

</emphasis>
. 

</para>





<para id="p1104">
<emphasis id="strong1111" effect="bold">
Possibly the most powerful concept in Java



</emphasis>
 

</para>





<para id="p1105">
This is possibly the most powerful 

<emphasis id="em1038" effect="italics">
(and most difficult) 

</emphasis>
concept embodied in the Java programming language. 

</para>





<para id="p1106">
<emphasis id="strong1112" effect="bold">
If you don't understand interfaces ...

</emphasis>
 

</para>





<para id="p1107">
I usually tell my students several times each semester that if they don't understand interfaces, they don't really understand Java.



</para>





<para id="p1108">
It is unlikely that you will ever be successful as a Java programmer without an understanding of interfaces.



</para>





<para id="p1109">
There are very few worthwhile programs that can be written in Java without an understanding of interfaces.



</para>





<para id="p1110">
<emphasis id="strong1113" effect="bold">
The core aspect



</emphasis>
 

</para>





<para id="p1111">
So, what is the core aspect of this concept that is so powerful?



</para>





<para id="p1112">
I told you earlier that each interface definition constitutes a new type.  As a result, a reference to any object instantiated from any class that implements a given interface can be treated as the type of the interface.



</para>





<para id="p1113">
<emphasis id="strong1114" effect="bold">
So what!

</emphasis>
 

</para>





<para id="p1114">
When a reference to an object is treated as an interface type, any method declared in, or inherited into that interface can be called on the reference to the object.



</para>





<para id="p1115">
However, the behavior of the method when called on references to different objects of the same interface type may be very different.  In the current jargon, the behavior is 


<emphasis id="em1039" effect="italics">
appropriate for the object on which it is called

</emphasis>
. 

</para>





<para id="p1116">
<emphasis id="strong1115" effect="bold">
One object, many types

</emphasis>
 

</para>





<para id="p1117">
Furthermore, because a single class can implement any number of different interfaces, a single object instantiated from a given class can be treated as any of the interface types implemented by the class from which it is instantiated.  Therefore, a single object in Java can be treated as many different types.

    

</para>





<para id="p1118">
<emphasis id="em1040" effect="italics">
(However, when an object is treated as an interface type, only those methods declared in that interface can be called on the object.  To call other methods on the object, it necessary to cast the object's reference to a different type.)



</emphasis>
 

</para>





<para id="p1119">
<emphasis id="strong1116" effect="bold">
Treating different types of objects as a common type



</emphasis>
 

</para>





<para id="p1120">
All of this also makes it possible to treat objects instantiated from widely differing classes as the same type, provided that all of those classes implement the same interface.

    

</para>





<para id="p1121">
<emphasis id="strong1117" effect="bold">
Important

</emphasis>
:  When an interface method is called on one of the objects using the reference of the interface type, the behavior of the method will be as defined by the author of the specific class that implemented the interface.  The behavior of the method will often be different for different objects instantiated from different classes that implement the same interface. 

</para>





<para id="p1122">
<emphasis id="strong1118" effect="bold">
Receiving parameters as interface types

</emphasis>
 

</para>





<para id="p1123">
Methods can receive parameters that are references of interface types.  In this case, the author of the code that calls interface methods on the incoming reference doesn't need to know, and often doesn't care, about the name of the class from which the object was instantiated.  


<emphasis id="em1041" effect="italics">
(For a discussion of this capability, see my tutorials on the Java 
Collections Framework, which you can read about


<link id="a1030" url="http://cnx.org/contents/dzOvxPFw:BaPSYll8">

here

</link>

.)

</emphasis>
</para>





<para id="p1124">
<emphasis id="strong1119" effect="bold">
A common example



</emphasis>
 

</para>





<para id="p1125">
A very common example is to store references to objects instantiated from different classes, 


<emphasis id="em1042" effect="italics">
(which implement the same interface)

</emphasis>
 in some sort of data structure (

<emphasis id="em1043" effect="italics">
such as list or a set)

</emphasis>
 and then to call the same methods on each of the references in the collection. 

</para>





<para id="p1126">
<emphasis id="strong1120" effect="bold">
Heart of the Delegation Event Model



</emphasis>
 

</para>





<para id="p1127">
For example, this methodology is at the heart of the 

<emphasis id="em1044" effect="italics">
Delegation Event Model

</emphasis>
, which forms the basis of Graphical User Interfaces and event-driven programming in Java. 

</para>





<para id="p1128">
This often entails defining classes that implement standard interfaces such as 


<emphasis id="strong1121" effect="bold">
MouseListener

</emphasis>
, 

<emphasis id="strong1122" effect="bold">
WindowListener

</emphasis>
, 

<emphasis id="strong1123" effect="bold">
TextListener

</emphasis>
, etc.  In this case, the programmer defines the interface methods to be appropriate for a listener object instantiated from a specific class.  Then a reference to the listener object is registered on an event source 


<emphasis id="em1045" effect="italics">
as the interface type

</emphasis>
. 

</para>





<para id="p1129">
Later when an event of that type occurs, the source object calls one or more interface methods on the listener object using the reference of the interface type.  The event source object doesn't know or care about the class from which the object was instantiated.  In fact, it doesn't even care how the interface method behaves when it is called.  The responsibility of the source object ends when it calls the appropriate interface method on the listener object.



</para>





<para id="p1130">
<emphasis id="strong1124" effect="bold">
Model View Control



</emphasis>
 

</para>





<para id="p1131">
This same methodology is also critical to the use of the 

<emphasis id="em1046" effect="italics">
Model View Control

</emphasis>
 paradigm in Java using the


<emphasis id="strong1125" effect="bold">
Observer

</emphasis>
 interface and the 

<emphasis id="strong1126" effect="bold">
Observable

</emphasis>
 class.  In this case, view objects instantiated from different classes that implement the 


<emphasis id="strong1127" effect="bold">
Observer

</emphasis>
 interface can register themselves on a model object that extends the 


<emphasis id="strong1128" effect="bold">
Observable

</emphasis>
 class.  Then each time the data being maintained in the model changes, each of the views will be notified so that they can update themselves. 

</para>





<para id="p1132">
<emphasis id="strong1129" effect="bold">
JavaBeans Components

</emphasis>
 

</para>





<para id="p1133">
This concept is also critical to the use of 

<emphasis id="em1047" effect="italics">
bound

</emphasis>
 and 

<emphasis id="em1048" effect="italics">
constrained

</emphasis>
 properties in JavaBeans Components.  One bean can register itself on other beans to be notified each time the value of a bound or constrained property changes.  In the case of constrained properties, the bean that is notified has the option of vetoing the change. 

</para>





<para id="p1134">
<emphasis id="strong1130" effect="bold">
Java Collections Framework

</emphasis>
 

</para>





<para id="p1135">
The Java Collections Framework is also totally dependent on the use of 
interfaces. As I mentioned earlier, you can read all about this in my tutorials 
on the Java Collections Framework, which you can read about


<link id="a1031" url="http://cnx.org/contents/dzOvxPFw:BaPSYll8">

here

</link>


<emphasis id="em1049" effect="italics">
.

</emphasis>
</para>





<para id="p1136">
<emphasis id="strong1131" effect="bold">
Iterators and Enumerators

</emphasis>
 

</para>





<para id="p1137">
If you appreciate data structures, you will also appreciate iterators.  In Java, 


<emphasis id="strong1132" effect="bold">
Iterator

</emphasis>
 is an interface, and an object that knows how to iterate across a data structure is an object of a class that implements the 


<emphasis id="strong1133" effect="bold">
Iterator

</emphasis>
 interface. 

</para>





<para id="p1138">
As a result, the users of the concrete implementations in the Java Collections Framework don't need to know any of the implementation details of the collection to create and use an iterator.  All of the work necessary to properly create an iterator is done by the author of the class that implements the appropriate Collection interfaces.  All the user needs to understand is the behavior of the three methods declared in the 


<emphasis id="strong1134" effect="bold">
Iterator

</emphasis>
 interface. 

</para>



	
	

</section>
<section id="h11004">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1139">
Polymorphic behavior, based on the Java interface, is one of the most important concepts in Java OOP



</para>





<para id="p1140">
In this module, I began my discussion of runtime polymorphism as implemented using method overriding and the Java interface.



</para>





<para id="p1141">
I presented a simple skeleton program that illustrated many of the important aspects of polymorphic behavior based on the Java interface.



</para>





<para id="p1142">
By using a nonstandard notation of my own design, 

<emphasis id="em1050" effect="italics">
(a totally abstract class)

</emphasis>
, I explained how the implementation of interfaces in Java is similar to multiple inheritance.



</para>





<para id="p1143">
I explained the cardinal rule, which is:

    

</para>





<para id="p1144">
<emphasis id="em1051" effect="italics">
If a class implements an interface, it must provide a concrete definition for all the methods declared by that interface, and all the methods inherited by that interface.  Otherwise, the class must be declared abstract and the definitions must be provided by a class that extends the abstract class.



</emphasis>



</para>





<para id="p1145">
I explained that objects instantiated from classes that implement the same interface have a new relationship that goes beyond the relationship imposed by the standard class hierarchy.



</para>





<para id="p1146">
I explained that due to the combination of the class hierarchy and the fact that a class can implement many different interfaces, a single object in Java can be treated as many different types.  However, for any given type, there are restrictions on the methods that can be called on the object.



</para>





<para id="p1147">
I also explained that because different classes can implement the same interface, objects instantiated from different classes can be treated as a common interface type.



</para>





<para id="p1148">
I suggested that there is little if anything useful that can be done in Java without understanding and using interfaces.



</para>





<para id="p1149">
Finally I discussed some real-world examples of the use of the Java interface:

    

</para>





<list id="ul1008" list-type="bulleted">

	

<item id="li1026">
Delegation event model
    

</item>


	

<item id="li1027">
Model View Control paradigm
    

</item>


	

<item id="li1028">
Bound and constrained properties in JavaBeans Components
    

</item>


	

<item id="li1029">
Java Collections Framework
    Iterators and Enumerators 

</item>




</list>




</section>
<section id="h11005">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1150">
In the next module, I will explain a more substantive program as I continue my discussion of polymorphic behavior using the Java interface.

</para>



	

</section>
<section id="h11006">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1151">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1135" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1009" list-type="bulleted">

					

<item id="li1030">
Module name: Java OOP: Polymorphism and Interfaces, Part 1


</item>


					

<item id="li1031">
File: Java1616.htm


</item>


					

<item id="li1032">
Published: 03/27/02 

</item>



				

</list>


				

</note>

			


		



	





	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1136" effect="bold">
Disclaimers:

</emphasis>
<para id="p1152">
<emphasis id="strong1137" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1153">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1154">
In the past, unknown individuals have misappropriated copies 
				of my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				receive no compensation for those sales and don't know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a bootleg copy of a module that is freely 
				available on cnx.org.

</para>



				

<para id="p1155">
<emphasis id="strong1138" effect="bold">
Affiliation

</emphasis>
:: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>



				

</note>

			


		



	





</section>
<section id="h11007">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1156">
A complete listing of the sample program is shown in 

<link id="a1032" target-id="Listing_6">

Listing 6

</link>

 below. 

</para>









<table id="table1005" summary="A table." pgwide="0">
<tgroup cols="1">





<thead id="thead1005">



<row id="tr1010">



<entry id="th1005">



<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. 

<emphasis id="strong1139" effect="bold">
Complete program listing.

</emphasis>



</entry>



</row>



</thead>





<tbody id="tbody1005">



<row id="tr1011">



<entry id="td1005">



<code id="pre1005" display="block">/*File Poly05.java
Copyright 2002, R.G.Baldwin
**************************************/

interface I1{
  public void p();
}//end interface I1
//===================================//

interface I2 extends I1{
  public void q();
}//end interface I2
//===================================//

class A extends Object{
  public String toString(){
    return "toString in A";
  }//end toString()
  //---------------------------------//
  
  public String x(){
    return "x in A";
  }//end x()
  //---------------------------------//
}//end class A
//===================================//

class B extends A implements I2{
  public void p(){
  }//end p()
  //---------------------------------//
  
  public void q(){
  }//end q();
  //---------------------------------//
}//end class B
//===================================//

class C extends Object implements I2{
  public void p(){
  }//end p()
  //---------------------------------//
  
  public void q(){
  }//end q();
  //---------------------------------//
}//end class B
//===================================//

public class Poly05{
  public static void main(String[] args){
  }//end main
}//end class Poly05</code>





</entry>



</row>



</tbody>





</tgroup>
</table>




<para id="p1157">
-end- 

</para>







</section>
</content>




</document>