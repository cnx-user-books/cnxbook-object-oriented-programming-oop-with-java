<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java0079 Java OOP Callbacks - III</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m59592</md:content-id>
  <md:title>Java0079 Java OOP Callbacks - III</md:title>
  <md:abstract>In a real program involving callbacks, many different objects may ask one object to notify them when any interesting event in a family of interesting events happens, and to identify the specific event that actually happened along with the notification. In addition, it is often desirable to encapsulate information in an object and to pass that object as a parameter when the callback method is invoked. This lesson will enhance the previous program by providing this capability.</md:abstract>
  <md:uuid>c6288129-3aa1-4b77-81f6-d6d0695d5636</md:uuid>
</metadata>

<content>






<para id="p1000">
Revised: Wed Jul 06 11:46:37 CDT 2016

</para>




<para id="p1001">
<emphasis id="em1000" effect="italics">
This page is included in the following Books:

</emphasis>
</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">

	

<link id="a1000" url="http://cnx.org/contents/Rl23r3Lw">


<emphasis id="em1001" effect="italics">
ITSE2317 - Java Programming (Intermediate)

</emphasis>
</link>


</item>


	

<item id="li1001">

	

<link id="a1001" url="http://cnx.org/contents/-2RmHFs_">


<emphasis id="em1002" effect="italics">
Object-Oriented Programming (OOP) with Java 
	

</emphasis>
 
	

</link>

 

</item>




</list>














<section id="h11000">
<title>
<emphasis id="Table_of_contents" effect="bold">

Table of contents

</emphasis>


</title>




<list id="ul1001" list-type="bulleted">
<item id="li1002">
<link id="a1002" target-id="Table_of_contents">

Table of contents

</link>




</item>


<item id="li1003">
<link id="a1003" target-id="Preface">

Preface

</link>




<list id="ul1002" list-type="bulleted">
<item id="li1004">
<link id="a1004" target-id="Viewing_tip">

Viewing tip

</link>




<list id="ul1003" list-type="bulleted">
<item id="li1005">
<link id="a1005" target-id="Listings">

Listings

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1006">
<link id="a1006" target-id="Introduction">

Introduction

</link>




</item>


<item id="li1007">
<link id="a1007" target-id="Sample_program">

Sample program

</link>




<list id="ul1004" list-type="bulleted">
<item id="li1008">
<link id="a1008" target-id="Interesting_code_fragments">

Interesting code fragments

</link>




<list id="ul1005" list-type="bulleted">
<item id="li1009">
<link id="a1009" target-id="The_interface_named_CallBack">

The interface named CallBack

</link>




</item>


<item id="li1010">
<link id="a1010" target-id="The_class_named_CallBackObjectClass">

The class named 
CallBackObjectClass

</link>




</item>


<item id="li1011">
<link id="a1011" target-id="The_class_named_CallBackAdapter">

The class named CallBackAdapter

</link>




</item>


<item id="li1012">
<link id="a1012" target-id="The_class_named_Teacher">

The class named Teacher

</link>




</item>


<item id="li1013">
<link id="a1013" target-id="The_class_named_Dog">

The class named Dog

</link>




</item>


<item id="li1014">
<link id="a1014" target-id="The_controlling_class_named_Callback04">

The controlling class named 
Callback04

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1015">
<link id="a1015" target-id="Summary">

Summary

</link>




</item>


<item id="li1016">
<link id="a1016" target-id="Complete_program_listings">

Complete program listings

</link>




</item>


<item id="li1017">
<link id="a1017" target-id="Miscellaneous">

Miscellaneous

</link>




</item>


</list>




	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
This is a page from the 
	

<link id="a1018" url="http://cnx.org/contents/Rl23r3Lw:qfO9iJX-">

Event Handling

</link>

 
	section of the book titled
	

<link id="a1019" url="http://cnx.org/contents/Rl23r3Lw:JVTd7bX1">

ITSE2317 - Java Programming (Intermediate)

</link>

. The 
	

<emphasis id="strong1000" effect="bold">
Event Handling

</emphasis>
 section explains how to write programs that handle 
	events in Java. 

</para>





<para id="p1003">
This is the third in a series of three lessons on Callbacks in Java. The three lessons are named Callbacks - I, Callbacks - II, and Callbacks - III.

Students in Prof. Baldwin's 

<emphasis id="strong1001" effect="bold">
ITSE 2317 Intermediate Java Programming

</emphasis>
 classes at ACC are responsible for knowing and understanding all of the material in this lesson. 

</para>



	
	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1004">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Listings while you are reading about them.

</para>





<section id="h31000">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>




<list id="ul1006" list-type="bulleted">



<item id="li1018">
<link id="a1020" target-id="Listing_1">

Listing 1

</link>


. The interface named CallBack.


</item>




<item id="li1019">
<link id="a1021" target-id="Listing_2">

Listing 2

</link>


. The class named CallBackObjectClass.


</item>




<item id="li1020">
<link id="a1022" target-id="Listing_3">

Listing 3

</link>


. The class named CallBackAdapter.


</item>




<item id="li1021">
<link id="a1023" target-id="Listing_4">

Listing 4

</link>


. Abbreviated version of the Teacher class.


</item>




<item id="li1022">
<link id="a1024" target-id="Listing_5">

Listing 5

</link>


. The class named Dog.


</item>




<item id="li1023">
<link id="a1025" target-id="Listing_6">

Listing 6

</link>


. The program named Callback04.


</item>




</list>






</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Introduction" effect="bold">

Introduction

</emphasis>


</title>




<para id="p1005">
Hopefully, by this point, you are familiar with the 

<emphasis id="em1003" effect="italics">
callback

</emphasis>
 material 
in the earlier lessons. Therefore, I will avoid, insofar as practical, 
repeating the introductory material from those lessons. 

</para>





<para id="p1006">
In a real program involving callbacks, many different objects may ask
one object to notify them when any interesting event in a 
family of interesting events happens, and to identify the specific event 
that actually happened along with the notification. 

</para>





<para id="p1007">
In addition, it is often desirable to encapsulate information in an object 
and to pass that object as a parameter when the callback method is invoked. This 
lesson will enhance the previous program by providing this capability. 

</para>





<para id="p1008">
Also, sometimes the interfaces used to implement callbacks declare many 
callback methods, and some classes are interested in only a few 
of those methods. It can become burdensome to have to provide large numbers of 
empty methods in all the classes that implement such an interface. For this 
reason, a mechanism known in Java terms as an 

<emphasis id="strong1002" effect="bold">
adapter 

</emphasis>
class is used to 
reduce the burden. 

</para>





<para id="p1009">
This lesson will show you how to create and use such 

<emphasis id="strong1003" effect="bold">
adapter 

</emphasis>
classes.


</para>





<para id="p1010">
We will continue with our earlier scenario consisting of a 

<emphasis id="em1004" effect="italics">
teacher 

</emphasis>
and 
some 

<emphasis id="em1005" effect="italics">
students

</emphasis>
. At this point, we have expanded our scenario to include 
many students and some animals in the classroom. 

</para>





<para id="p1011">
The students 

<emphasis id="em1006" effect="italics">
(and the animals)

</emphasis>
 register themselves on the teachers roll book 
to be notified when it is time for recess, or

<emphasis id="em1007" effect="italics">
 

</emphasis>
it is time for lunch. 

</para>





<para id="p1012">
In this lesson, as in the earlier lesson, all of the students and all of the 
animals receive notification of both types of events (

<emphasis id="em1008" effect="italics">
recess 

</emphasis>
or 

<emphasis id="em1009" effect="italics">
lunch

</emphasis>
) 
but some of those who are notified choose to ignore the notification. However, 
in this lesson, the methodology for ignoring the notification is different than 
it was in the previous lesson. 

</para>




	

</section>
<section id="h11003">
<title>
<emphasis id="Sample_program" effect="bold">

Sample program

</emphasis>


</title>


	
	

<para id="p1013">
In case you just started reading at this point, this program named
	

<emphasis id="strong1004" effect="bold">
Callback04

</emphasis>
 is an enhanced version of the earlier program 
	named 

<emphasis id="strong1005" effect="bold">
Callback03

</emphasis>
. You should familiarize yourself with the 
	earlier program before trying to understand this program. 

</para>





<para id="p1014">
This version of the program makes two unrelated enhancements to the program 
named 

<emphasis id="strong1006" effect="bold">
Callback03

</emphasis>
. 

</para>





<list id="ul1007" list-type="bulleted">

	

<item id="li1024">
First, a new class is defined in conjunction with the 

<emphasis id="strong1007" effect="bold">
CallBack
	

</emphasis>
interface that makes it possible for the 

<emphasis id="strong1008" effect="bold">
Teacher 

</emphasis>

	class to encapsulate information into an object and pass that object as a 
	parameter whenever a callback is made. 

</item>


	

<item id="li1025">
Second, a new class is defined in conjunction with the 

<emphasis id="strong1009" effect="bold">
CallBack
	

</emphasis>
interface which, in Java terminology, is often called an 

<emphasis id="strong1010" effect="bold">

	adapter 

</emphasis>
class. 

</item>




</list>




<para id="p1015">
An 

<emphasis id="strong1011" effect="bold">
adapter

</emphasis>
 class, as defined here, is a convenience class 
that implements the interface and defines all the methods declared in the 
interface with empty methods. Then any class that needs to implement the 
interface can 

<emphasis id="em1010" effect="italics">
<emphasis id="strong1012" effect="bold">
extend

</emphasis>
 

</emphasis>
the adapter class without a 
requirement to define those methods that are not of interest. 

</para>





<para id="p1016">
In this version of the program, the 

<emphasis id="strong1013" effect="bold">
CallBack

</emphasis>
 interface is 
expanded to declare several dummy methods to emphasize this benefit of the use 
of an 

<emphasis id="strong1014" effect="bold">
adapter 

</emphasis>
class. 

</para>





<para id="p1017">
Note that objects of a class that 

<emphasis id="em1011" effect="italics">
extends 

</emphasis>
the adapter class can be 
referred to by the interface type. Thus, interface type is an inherited 
attribute that results from 

<emphasis id="em1012" effect="italics">
extending 

</emphasis>
a class that 

<emphasis id="em1013" effect="italics">
implements 

</emphasis>

an interface. 

</para>





<para id="p1018">
Using an 

<emphasis id="strong1015" effect="bold">
adapter 

</emphasis>
class also makes it possible to expand the 
interface later, by declaring new methods, without breaking code that already


<emphasis id="strong1016" effect="bold">
implements 

</emphasis>
the interface, provided that the 

<emphasis id="strong1017" effect="bold">
adapter

</emphasis>
 
class is appropriately redefined. In this sense, the 

<emphasis id="strong1018" effect="bold">
adapter

</emphasis>
 
class is a little more than a convenience class. 

</para>





<para id="p1019">
This version of the program defines three different classes named 

<emphasis id="strong1019" effect="bold">

Student

</emphasis>
, 

<emphasis id="strong1020" effect="bold">
Dog

</emphasis>
, and 

<emphasis id="strong1021" effect="bold">
Cat

</emphasis>
, that 

<emphasis id="em1014" effect="italics">

implement 

</emphasis>
the 

<emphasis id="strong1022" effect="bold">
CallBack 

</emphasis>
interface 

<emphasis id="em1015" effect="italics">
indirectly 

</emphasis>
by 
extending the adapter class. 

</para>





<para id="p1020">
Mixed objects of these three types are maintained in a common list and 
notified at callback time. 

</para>





<para id="p1021">
As in the previous version of the program, the 

<emphasis id="strong1023" effect="bold">
Dog 

</emphasis>
class 
ignores the

<emphasis id="strong1024" effect="bold">
 recess 

</emphasis>
callback and the 

<emphasis id="strong1025" effect="bold">
Cat 

</emphasis>

class ignores the 

<emphasis id="strong1026" effect="bold">
lunch

</emphasis>
 callback. In this program, these 
classes simply don't bother to override methods of the interface that are not of 
interest. 

</para>





<para id="p1022">
The 

<emphasis id="strong1027" effect="bold">
Student 

</emphasis>
class responds to both types of callbacks with 
fully- defined methods. 

</para>





<para id="p1023">
The program defines a 

<emphasis id="strong1028" effect="bold">
Teacher 

</emphasis>
class that has the ability to 
create and maintain a list of objects of the interface type, and to notify those 
objects that something interesting has happened by invoking either the 

<emphasis id="strong1029" effect="bold">

recess

</emphasis>
 method or the 

<emphasis id="strong1030" effect="bold">
lunch

</emphasis>
 method on all the objects 
on the list. An object is instantiated and passed as a parameter whenever one or 
the other of these methods is invoked. 

</para>





<para id="p1024">
Finally, the program defines a controlling class that ties all the pieces 
together and exercises them. 

</para>





<para id="p1025">
The program was originally tested using JDK 1.1.3 under Win95. More recently 
it was tested using Java 8 and Windows 7.

</para>






<section id="h21001">
<title>
<emphasis id="Interesting_code_fragments" effect="bold">

Interesting code fragments

</emphasis>


</title>





<section id="h31001">
<title>
<emphasis id="The_interface_named_CallBack" effect="bold">

The interface named CallBack

</emphasis>


</title>




<para id="p1026">
We begin by defining an interface named 

<emphasis id="strong1031" effect="bold">
CallBack

</emphasis>
 that will create a new type and will 
declare two generic methods that can be used to callback any object that is of a 
class that implements the interface. The interface named 

<emphasis id="strong1032" effect="bold">
CallBack

</emphasis>
 
is shown in 

<link id="a1026" target-id="Listing_1">

 Listing 1

</link>

.

</para>






<note id="note1000" type="">



 











<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. The interface named CallBack.


<code id="pre1000" display="block">
interface CallBack{
  public void recess(CallBackObjectClass obj);
  public void lunch(CallBackObjectClass obj);
  
  public void dummy1(CallBackObjectClass obj);
  public void dummy2(CallBackObjectClass obj);
  public void dummy3(CallBackObjectClass obj);
  public void dummy4(CallBackObjectClass obj);
  public void dummy5(CallBackObjectClass obj);
  public void dummy6(CallBackObjectClass obj);

}//end interface CallBack
</code>




</note>















<para id="p1027">
Note that in addition to two methods mentioned above, the interface also declares
several additional dummy methods to emphasize the benefit of 
extending the adapter class that is defined later. 

</para>





<para id="p1028">
Note also that the methods now require a parameter, which was not the case in 
earlier lessons. The 
class for this parameter will be defined soon next.

</para>





</section>
<section id="h31002">
<title>
<emphasis id="The_class_named_CallBackObjectClass" effect="bold">

The class named 
CallBackObjectClass

</emphasis>


</title>






<para id="p1029">
<link id="a1027" target-id="Listing_2">

 Listing 2

</link>

 defines a class from which we can instantiate 
an object to pass as a parameter in the callback methods. This class can be as 
simple or as elaborate as needed to convey the amount and type of information 
needed with the callback. In our case, it contains a single 

<emphasis id="strong1033" effect="bold">
String

</emphasis>
 
object. 

</para>










<note id="note1001" type="">



 











<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. The class named CallBackObjectClass.


<code id="pre1001" display="block">
class CallBackObjectClass{
  String data;
  
  CallBackObjectClass(String data){//constructor
    this.data = data;
  }//end constructor
}//end CallBackObjectClass
</code>




</note>















</section>
<section id="h31003">
<title>
<emphasis id="The_class_named_CallBackAdapter" effect="bold">

The class named CallBackAdapter

</emphasis>


</title>




<para id="p1030">
<link id="a1028" target-id="Listing_3">

 Listing 3

</link>

 shows the definition of the adapter class for the 

<emphasis id="strong1034" effect="bold">
CallBack 

</emphasis>
interface. This class defines all the interface methods with empty 
methods. 

</para>









<note id="note1002" type="">



 











<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. The class named CallBackAdapter.


<code id="pre1002" display="block">
class CallBackAdapter implements CallBack{
  public void recess(CallBackObjectClass obj){};
  public void lunch(CallBackObjectClass obj){};
  
  public void dummy1(CallBackObjectClass obj){};
  public void dummy2(CallBackObjectClass obj){};
  public void dummy3(CallBackObjectClass obj){};
  public void dummy4(CallBackObjectClass obj){};
  public void dummy5(CallBackObjectClass obj){};
  public void dummy6(CallBackObjectClass obj){};  
}//end class CallBackAdapter
</code>




</note>















<para id="p1031">
Classes that need to 

<emphasis id="em1016" effect="italics">
implement

</emphasis>
 the 

<emphasis id="strong1035" effect="bold">
CallBack

</emphasis>
 interface can now 

</para>





<list id="ul1008" list-type="bulleted">

	

<item id="li1026">
<emphasis id="em1017" effect="italics">
extend 

</emphasis>
the 

<emphasis id="strong1036" effect="bold">
CallBackAdapter

</emphasis>
 class,

</item>


	

<item id="li1027">
<emphasis id="em1018" effect="italics">
override 

</emphasis>
only the empty methods of interest, and 


</item>


	

<item id="li1028">
ignore the other methods. 

</item>




</list>




<para id="p1032">
It is important to note that the existence of the 

<emphasis id="strong1037" effect="bold">

adapter

</emphasis>
 does not prevent another class from 

<emphasis id="em1019" effect="italics">
implementing

</emphasis>
 the 
interface instead of 

<emphasis id="em1020" effect="italics">
extending

</emphasis>
 the 

<emphasis id="strong1038" effect="bold">
adapter

</emphasis>
 class. 

</para>





<para id="p1033">
Objects of a class that 

<emphasis id="em1021" effect="italics">
extends 

</emphasis>
the 

<emphasis id="strong1039" effect="bold">
CallBackAdapter

</emphasis>
 class can be referenced as the 
interface type 

<emphasis id="strong1040" effect="bold">
CallBack

</emphasis>
.

</para>





</section>
<section id="h31004">
<title>
<emphasis id="The_class_named_Teacher" effect="bold">

The class named Teacher

</emphasis>


</title>





<para id="p1034">
Next we need a class whose objects can maintain a list of registered objects 
of type 

<emphasis id="strong1041" effect="bold">
CallBack 

</emphasis>
and can notify all the objects on that list 
when something interesting happens. This class has the ability to invoke two 
different callback methods: 

<emphasis id="strong1042" effect="bold">
recess

</emphasis>
 and 

<emphasis id="strong1043" effect="bold">
lunch

</emphasis>
.


</para>





<para id="p1035">
Obviously, if you have been following this development, you will know by now 
that this is the class named 

<emphasis id="strong1044" effect="bold">
Teacher

</emphasis>
. 

</para>





<para id="p1036">
The only thing significantly different about this version of the 

<emphasis id="strong1045" effect="bold">

Teacher

</emphasis>
 class is the fact that it instantiates and passes an object of 
type 

<emphasis id="strong1046" effect="bold">
CallBackObjectClass

</emphasis>
 whenever it makes a callback. 

</para>





<para id="p1037">
Since you have seen this method several times before, and should be very 
familiar with it by now, I am going to delete most of the code in the class and 
show you only that portion of the code that invokes the 

<emphasis id="strong1047" effect="bold">
recess

</emphasis>
 
callback method on all the objects on the list, instantiating and passing an 
object of type 

<emphasis id="strong1048" effect="bold">
CallBackObjectClass

</emphasis>
 as a parameter in each case.
The abbreviated version of the 

<emphasis id="strong1049" effect="bold">
Teacher

</emphasis>
 class is shown in 


<link id="a1029" target-id="Listing_4">

 Listing 4

</link>

.

</para>







<note id="note1003" type="">



 











<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Abbreviated version of the Teacher class.


<code id="pre1003" display="block">
class Teacher{
  //code deleted

  void callRecess(){
    //code deleted

    for(int cnt = 0; cnt &lt; tempList.size(); cnt++){
      ((CallBack)tempList.elementAt(cnt)).recess(
                      new CallBackObjectClass(" Recess"));
    }//end for loop
  }//end callRecess()
  //code deleted

}//end class Teacher
</code>




</note>















</section>
<section id="h31005">
<title>
<emphasis id="The_class_named_Dog" effect="bold">

The class named Dog

</emphasis>


</title>




<para id="p1038">
That brings us to the three classes that implement the 

<emphasis id="strong1050" effect="bold">
CallBack 

</emphasis>
interface 

<emphasis id="em1022" effect="italics">
indirectly 

</emphasis>
by 

<emphasis id="em1023" effect="italics">
extending 

</emphasis>
the 

<emphasis id="strong1051" effect="bold">

CallBackAdapter 

</emphasis>
class. 

</para>





<para id="p1039">
Objects of these three classes can be registered on the list maintained by an 
object of the 

<emphasis id="strong1052" effect="bold">
Teacher 

</emphasis>
class, and will be notified whenever that 
object invokes either the 

<emphasis id="strong1053" effect="bold">
recess

</emphasis>
 method or the 

<emphasis id="strong1054" effect="bold">
lunch

</emphasis>
 method on the registered objects on the list. 

</para>





<para id="p1040">
Part of the notification will be an object passed as a parameter to the 
callback method. Code in the callback method can either ignore that object, or 
can extract the information from the object and use it. 

</para>





<para id="p1041">
These three classes are very similar, so I will show you only one of them 
here. To be consistent with the previous lesson, I will show you the definition 
for the 

<emphasis id="strong1055" effect="bold">
Dog

</emphasis>
 class that ignores the 

<emphasis id="strong1056" effect="bold">
recess

</emphasis>
 
callback. This class, which is shown in 

<link id="a1030" target-id="Listing_5">

 Listing 5

</link>

, also ignores all of the 

<emphasis id="em1024" effect="italics">

dummy 

</emphasis>
methods that were 
declared in the 

<emphasis id="strong1057" effect="bold">
CallBack

</emphasis>
 i interface in this program. 

</para>









<note id="note1004" type="">



 











<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. The class named Dog.


<code id="pre1004" display="block">
class Dog extends CallBackAdapter{
  String name; //store name here for later ID
  //-----------------------------------------------------//
  
  Dog(String name){//constructor
    this.name = name; //save the name to identify the obj
  }//end constructor
  //-----------------------------------------------------//

  //An object of the Teacher class can invoke this 
  // method as a callback mechanism passing an object
  // as a parameter.
  public void lunch(CallBackObjectClass obj){//announce
    System.out.println(name + obj.data);
  }//end overridden lunch()
  //-----------------------------------------------------//
}//end class Dog
</code>




</note>















<para id="p1042">
Note first that this class 

<emphasis id="em1025" effect="italics">
extends

</emphasis>
 the 

<emphasis id="strong1058" effect="bold">
CallBackAdapter

</emphasis>
 
class and does not 

<emphasis id="em1026" effect="italics">
implement 

</emphasis>
any interfaces. 

</para>





<para id="p1043">
Note also that it only overrides the 

<emphasis id="strong1059" effect="bold">
lunch

</emphasis>
 method from the


<emphasis id="strong1060" effect="bold">
adapter

</emphasis>
 class, ignoring all of the other empty methods defined 
in that class. Were it not for the 

<emphasis id="strong1061" effect="bold">
adapter

</emphasis>
 class in this case, 
this 

<emphasis id="strong1062" effect="bold">
Dog

</emphasis>
 class definition would have to define the six dummy 
methods and the 

<emphasis id="strong1063" effect="bold">
recess

</emphasis>
 method with empty methods. Therefore, 
the availability of an adapter class can be a real convenience for the 
programmer. 

</para>





<para id="p1044">
Finally, note that code in the 

<emphasis id="strong1064" effect="bold">
lunch

</emphasis>
 method extracts the 
instance variable named 

<emphasis id="strong1065" effect="bold">
data

</emphasis>
 and displays that information 
instead of a literal string as was the case in the earlier versions of this 
program. 

</para>





</section>
<section id="h31006">
<title>
<emphasis id="The_controlling_class_named_Callback04" effect="bold">

The controlling class named 
Callback04

</emphasis>


</title>




<para id="p1045">
That brings us to the controlling class that ties all the other pieces 
together and exercises them. The controlling class in this version of the 
program is no different from that of the earlier version named 

<emphasis id="strong1066" effect="bold">

Callback03

</emphasis>
. 

</para>





<para id="p1046">
Also, the output from running this version of the program is almost the same 
as the earlier version, with the main difference being that the callback methods 
display information encapsulated in an object passed to the method which was not 
the case in the earlier versions. The output can be seen in the complete program 
listing shown in 

<link id="a1031" target-id="Listing_6">

 Listing 6

</link>

. 

</para>





<para id="p1047">
Therefore, there should be no need to provide any further discussion 
regarding the testing of this version of the program.

</para>






</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1048">
We have objects of different classes registered on a common callback list 
where every object on the list receives a callback for every different type of 
callback event associated with the list. 

</para>





<para id="p1049">
Whenever a callback occurs, an object is instantiated to contain information 
and passed as a parameter to the callback method. The code in the callback 
method can either ignore that object, or extract the information from the object 
and use it. In this program, the code in the callback methods extracts and 
displays the information encapsulated in the object. 

</para>





<para id="p1050">
The different types of callbacks are established by the method declarations 
in the 

<emphasis id="strong1067" effect="bold">
CallBack 

</emphasis>
interface. 

</para>





<para id="p1051">
An 

<emphasis id="strong1068" effect="bold">
adapter 

</emphasis>
class is defined that implements the 

<emphasis id="strong1069" effect="bold">

CallBack 

</emphasis>
interface and defines all of its methods as empty methods. 

</para>





<para id="p1052">
Each class of object that registers for callbacks can either respond to all 
of the different types of callbacks by overriding all of the callback methods in 
the 

<emphasis id="strong1070" effect="bold">
adapter

</emphasis>
 class, or can selectively ignore some types of 
callbacks simply by not overriding those methods. 

</para>





<para id="p1053">
Such a class can also ignore the 

<emphasis id="strong1071" effect="bold">
adapter

</emphasis>
 class and 

<emphasis id="em1027" effect="italics">

implement

</emphasis>
 the interface directly as in the earlier lessons. 

</para>





</section>
<section id="h11005">
<title>
<emphasis id="Complete_program_listings" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1054">
A complete listing of the program is shown in 

<link id="a1032" target-id="Listing_6">

 Listing 6

</link>

.

</para>










<note id="note1005" type="">



 











<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. The program named Callback04.


<code id="pre1005" display="block">
/*File Callback04.java Copyright 1997, R.G.Baldwin
The purpose of this program is to develop a callback
capability using Interfaces.  

This is an enhanced version of the program named 
Callback03.  You should familiarize yourself with
the earlier program before getting into this program.

This version of the program makes two unrelated 
enhancements to the program named Callback03.

First, a new class is defined in conjunction with the
CallBack interface that makes it possible for the
Teacher class to encapsulate information into an object
and pass that object whenever a callback is made.

Second, a new class is defined in conjunction with the
CallBack interface which, in Java terminology, is often
called an adapter class.  This is a convenience class
that implements the interface and defines all the 
methods declared in the interface with empty methods.
Then any class that needs to implement the interface 
can extend the adapter class without a requirement to 
define those methods that are not of interest.

In this case, the interface is expanded to declare 
several dummy methods to emphasize this benefit of
the use of an adapter class.

Note that objects of classes that extend the adapter
class that implements the interface can be referred to 
by the interface type. Thus, interface type is an
inherited attribute that results from extending a class.

Using an adapter class also makes it possible to expand
the interface later by declaring new methods without 
breaking code that already implements the interface.

This version defines three different classes named 
Student, Dog, and Cat, that implement the CallBack 
interface indirectly by extending the adapter class.
These classes simply don't bother to define
methods of the interface that are not of interest.

Mixed objects of these three types are maintained 
on a list and notified at CallBack time.

The Dog class ignores the recess() callback and the 
Cat class ignores the lunch() callback.  The Student
class responds to both types of callbacks with fully-
defined methods.

The program defines a Teacher class that has the 
ability to create and maintain a list of objects
of the interface type, and to notify those objects
that something interesting has happened by invoking
either the recess() method or the lunch() method on all 
the objects on the list.

Finally, the program defines a controlling class that
ties all the pieces together and exercises them.

Tested using JDK 1.1.3 under Win95.

The output from the program was:

Tom Recess
Sue Recess
CleoCat Recess
Peg Recess
KittyKat Recess
Bob Recess
Tom Lunch
SpotDog Lunch
Sue Lunch
FidoDog Lunch
Peg Lunch
Bob Lunch
BrownieDog Lunch
**********************************************************/
import java.util.*;

//First we define an interface that will create a new type
// and declare two generic methods that can be used to 
// callback any object that is of a class that implements
// the interface. Note that the methods now require a
// parameter. Note also that we have declared several
// additional dummy methods to emphasize the benefit of 
// extending the adapter class that is defined later.
interface CallBack{
  public void recess(CallBackObjectClass obj);
  public void lunch(CallBackObjectClass obj);
  
  public void dummy1(CallBackObjectClass obj);
  public void dummy2(CallBackObjectClass obj);
  public void dummy3(CallBackObjectClass obj);
  public void dummy4(CallBackObjectClass obj);
  public void dummy5(CallBackObjectClass obj);
  public void dummy6(CallBackObjectClass obj);

}//end interface CallBack
//=======================================================//

//Now we need a class that can be instantiated to
// pass an object in the callback methods.
class CallBackObjectClass{
  String data;
  
  CallBackObjectClass(String data){//constructor
    this.data = data;
  }//end constructor
}//end CallBackObjectClass
//=======================================================//

//Now we need an adapter class for the CallBack interface.
// This class defines all the interface methods with
// empty methods.  Classes that need the interface can
// now extend this class and override only the empty 
// methods of interest, and ignore the others. Note that 
// objects of a class that extends this class can be 
// referenced as the interface type CallBack.
class CallBackAdapter implements CallBack{
  public void recess(CallBackObjectClass obj){};
  public void lunch(CallBackObjectClass obj){};
  
  public void dummy1(CallBackObjectClass obj){};
  public void dummy2(CallBackObjectClass obj){};
  public void dummy3(CallBackObjectClass obj){};
  public void dummy4(CallBackObjectClass obj){};
  public void dummy5(CallBackObjectClass obj){};
  public void dummy6(CallBackObjectClass obj){};  
}//end class CallBackAdapter
//=======================================================//

//Next we need a class whose objects can maintain a 
// registered list of objects of type CallBack and can 
// notify all the objects on that list when something
// interesting happens. This class has the ability to
// notify two different types of callbacks, recess()
// and lunch().  

class Teacher{
  Vector objList; //list of objects of type CallBack
  //-----------------------------------------------------//
  
  Teacher(){//constructor
    //Instantiate a Vector object to contain the list
    // of registered objects.
    objList = new Vector();
  }//end constructor
  //-----------------------------------------------------//
  
  //Method to add objects to the list.
  synchronized void register(CallBack obj){
    this.objList.addElement(obj);
  }//end register()
  //-----------------------------------------------------//
  
  //Method to remove objects from the list.
  synchronized void unRegister(CallBack obj){
    if(this.objList.removeElement(obj))
      System.out.println(obj + " removed");
    else
      System.out.println(obj + " not in the list");
  }//end register()
  //-----------------------------------------------------//
  
  //Method to notify all objects on the list that 
  // something interesting has happened regarding 
  // recess and to pass information to the object
  // encapsulated in an object as a parameter.
  void callRecess(){
    Vector tempList;//save a temporary copy of list here
    
    //Make a copy of the list.
    synchronized(this){
      tempList = (Vector)objList.clone();
    }//end synchronized block
    
    //Invoke the recess() method on each object on
    // the list, passing an object as a parameter.
    for(int cnt = 0; cnt &lt; tempList.size(); cnt++){
      ((CallBack)tempList.elementAt(cnt)).recess(
                      new CallBackObjectClass(" Recess"));
    }//end for loop
  }//end callRecess()
  //-----------------------------------------------------//
  //Method to notify all objects on the list that 
  // something interesting has happened regarding 
  // lunch and to pass an object containing information
  // as a parameter to the callback method.
  void callLunch(){
    Vector tempList;//save a temporary copy of list here
    
    //Make a copy of the list.
    synchronized(this){
      tempList = (Vector)objList.clone();
    }//end synchronized block
    
    //Invoke the lunch() method on each object on
    // the list, passing an object as a parameter.
    for(int cnt = 0; cnt &lt; tempList.size(); cnt++){
      ((CallBack)tempList.elementAt(cnt)).lunch(
                       new CallBackObjectClass(" Lunch"));
    }//end for loop
  }//end callRecess()
  //-----------------------------------------------------//
}//end class Teacher
//=======================================================//

//Class that implements the CallBack interface indirectly
// by extending the CallBackAdapter class.  Objects
// of this class can be registered on the list maintained
// by an object of the Teacher class, and will be notified
// whenever that object invokes either the recess() method
// or the lunch() method on the registered objects on 
// the list.  This method provides a full definition for
// both methods.

class Student extends CallBackAdapter{
  String name; //store the object name here for later ID
  //-----------------------------------------------------//
  
  Student(String name){//constructor
    this.name = name;  //save the name to identify the obj
  }//end constructor
  //-----------------------------------------------------//

  //An object of the Teacher class can invoke this method
  // as a callback mechanism. Note that this method
  // displays the data encapsulated in the incoming 
  // object.
  public void recess(CallBackObjectClass obj){//announce
    System.out.println(name + obj.data);
  }//end overridden recess()
  //-----------------------------------------------------//

  //An object of the Teacher class can also invoke this 
  // method as a callback mechanism passing an object
  // as a parameter.
  public void lunch(CallBackObjectClass obj){//announce
    System.out.println(name + obj.data);
  }//end overridden lunch()
  //-----------------------------------------------------//
}//end class Student

//=======================================================//

//Another Class that implements the CallBack interface
// indirectly by extending the CallBackAdapter class.  
// See description above. This class ignores the recess()
// method as well as the dummy methods.

class Dog extends CallBackAdapter{
  String name; //store name here for later ID
  //-----------------------------------------------------//
  
  Dog(String name){//constructor
    this.name = name; //save the name to identify the obj
  }//end constructor
  //-----------------------------------------------------//

  //An object of the Teacher class can invoke this 
  // method as a callback mechanism passing an object
  // as a parameter.
  public void lunch(CallBackObjectClass obj){//announce
    System.out.println(name + obj.data);
  }//end overridden lunch()
  //-----------------------------------------------------//
}//end class Dog
//=======================================================//

//A third Class that implements the CallBack interface
// indirectly by extending the CallBackAdapter class,
// similar to the other two classes.  This class ignores
// the lunch() method as well as the dummy methods.

class Cat extends CallBackAdapter{
  String name; //store name here for later ID
  //-----------------------------------------------------//
  
  Cat(String name){//constructor
    this.name = name; //save the name to identify the obj
  }//end constructor
  //-----------------------------------------------------//

  //An object of the Teacher class can invoke this method
  // as the callback mechanism, passing an object as a
  // parameter.
  public void recess(CallBackObjectClass obj){//announce
    System.out.println(name + obj.data);
  }//end overridden recess()
  //-----------------------------------------------------//
}//end class Cat
//=======================================================//

//Controlling class that ties all the pieces together and
// exercises them.
class Callback04{
  public static void main(String[] args){
    //Instantiate Teacher object
    Teacher missJones = new Teacher();

    //Instantiate some Student objects
    Student tom = new Student("Tom");
    Student sue = new Student("Sue");
    Student peg = new Student("Peg");
    Student bob = new Student("Bob");
    Student joe = new Student("Joe");
    
    //Instantiate some Dog objects.
    Dog spot = new Dog("SpotDog");
    Dog fido = new Dog("FidoDog");
    Dog brownie = new Dog("BrownieDog");
    
    //Instantiate some Cat objects
    Cat cleo = new Cat("CleoCat");
    Cat kitty = new Cat("KittyKat");

    //Register some Student, Dog, and Cat objects with 
    // the Teacher object.
    missJones.register(tom);
    missJones.register(spot);
    missJones.register(sue);
    missJones.register(cleo);
    missJones.register(fido);
    missJones.register(peg);
    missJones.register(kitty);
    missJones.register(bob);
    missJones.register(brownie);
    
    //Cause the Teacher object to call recess on all
    // the objects on the list.
    missJones.callRecess();
    //Cause the Teacher object to call lunch on all
    // the objects on the list.
    missJones.callLunch();
  }//end main()
}//end class Callback04
//=======================================================//
</code>




</note>















	

</section>
<section id="h11006">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1055">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1006" type="">


		


			


				

<emphasis id="strong1072" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1009" list-type="bulleted">

					

<item id="li1029">
Module name: Java0079 Java OOP Callbacks - III

</item>


					

<item id="li1030">
File: Java0079.htm

</item>


					

<item id="li1031">
Originally published: 1997

</item>



				

</list>



				

</note>





	

<note id="note1007" type="">


		


			


				

<emphasis id="strong1073" effect="bold">
Disclaimers:

</emphasis>
<para id="p1056">
<emphasis id="strong1074" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1057">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1058">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1059">
<emphasis id="strong1075" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>




</note>



	
	



<para id="p1060">
-end- 

</para>







</section>
</content>




</document>